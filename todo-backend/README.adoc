ifdef::env-github[]
:artifactId: todo-backend
endif::[]

//***********************************************************************************
// Enable the following flag to build README.html files for JBoss EAP product builds.
// Comment it out for WildFly builds.
//***********************************************************************************
//:ProductRelease:

//***********************************************************************************
// Enable the following flag to build README.html files for EAP XP product builds.
// Comment it out for WildFly or JBoss EAP product builds.
//***********************************************************************************
//:EAPXPRelease:

// This is a universal name for all releases
:ProductShortName: JBoss EAP
// Product names and links are dependent on whether it is a product release (CD or JBoss)
// or the WildFly project.
// The "DocInfo*" attributes are used to build the book links to the product documentation

ifdef::ProductRelease[]
// JBoss EAP release
:productName: JBoss EAP
:productNameFull: Red Hat JBoss Enterprise Application Platform
:productVersion: 8.1
:DocInfoProductNumber: {productVersion}
:WildFlyQuickStartRepoTag: 8.1.x
:helmChartName: jboss-eap/eap81
endif::[]

ifdef::EAPXPRelease[]
// JBoss EAP XP release
:productName: JBoss EAP XP
:productNameFull: Red Hat JBoss Enterprise Application Platform expansion pack
:productVersion: 5.0
:WildFlyQuickStartRepoTag: XP_5.0.0.GA
endif::[]

ifdef::ProductRelease,EAPXPRelease[]
:githubRepoUrl: https://github.com/jboss-developer/jboss-eap-quickstarts/
:githubRepoCodeUrl: https://github.com/jboss-developer/jboss-eap-quickstarts.git
:jbossHomeName: EAP_HOME
:DocInfoProductName: Red Hat JBoss Enterprise Application Platform
:DocInfoProductNameURL: red_hat_jboss_enterprise_application_platform
:DocInfoPreviousProductName: jboss-enterprise-application-platform
:quickstartDownloadName: {productNameFull} {productVersion} Quickstarts
:quickstartDownloadUrl: https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=appplatform&downloadType=distributions
:helmRepoName: jboss-eap
:helmRepoUrl: https://jbossas.github.io/eap-charts/
// END ifdef::ProductRelease,EAPXPRelease[]
endif::[]

ifndef::ProductRelease,EAPXPRelease[]
// WildFly project
:productName: WildFly
:productNameFull: WildFly Application Server
:ProductShortName: {productName}
:jbossHomeName: WILDFLY_HOME
:productVersion: 39
:githubRepoUrl: https://github.com/wildfly/quickstart/
:githubRepoCodeUrl: https://github.com/wildfly/quickstart.git
:WildFlyQuickStartRepoTag: 38.0.0.Final
:DocInfoProductName: Red Hat JBoss Enterprise Application Platform
:DocInfoProductNameURL: red_hat_jboss_enterprise_application_platform
:DocInfoPreviousProductName: jboss-enterprise-application-platform
:helmRepoName: wildfly
:helmRepoUrl: http://docs.wildfly.org/wildfly-charts/
:helmChartName: wildfly/wildfly
// END ifndef::ProductRelease,EAPCDRelease,EAPXPRelease[]
endif::[]

:source: {githubRepoUrl}

// Values for Openshift S2i sections attributes
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {EapForOpenshiftBookName} Online
:xpaasproduct: {productNameFull} for OpenShift
:xpaasproduct-shortname: {ProductShortName} for OpenShift
:ContainerRegistryName: Red Hat Container Registry
:EapForOpenshiftBookName: Getting Started with {ProductShortName} for OpenShift Container Platform
:EapForOpenshiftOnlineBookName: Getting Started with {ProductShortName} for OpenShift Online
:OpenShiftOnlinePlatformName: Red Hat OpenShift Container Platform
:OpenShiftOnlineName: Red Hat OpenShift Online
// Links to the OpenShift documentation
:LinkOpenShiftGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_with_jboss_eap_for_openshift_container_platform/
:LinkOpenShiftOnlineGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_with_jboss_eap_for_openshift_online/

ifdef::EAPXPRelease[]
// Attributes for XP releases
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {productNameFull} for OpenShift Online
:xpaasproduct: {productNameFull} for OpenShift
:ContainerRegistryName: Red Hat Container Registry
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {productNameFull} for OpenShift Online
// Links to the OpenShift documentation
:LinkOpenShiftGuide: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/{DocInfoProductNumber}/html/using_eclipse_microprofile_in_jboss_eap/using-the-openshift-image-for-jboss-eap-xp_default
:LinkOpenShiftOnlineGuide: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/{DocInfoProductNumber}/html/using_eclipse_microprofile_in_jboss_eap/using-the-openshift-image-for-jboss-eap-xp_default
endif::[]

//*************************
// Other values
//*************************
:buildRequirements: Java SE 17.0 or later, and Maven 3.6.0 or later
:javaVersion: Jakarta EE 10
ifdef::EAPXPRelease[]
:javaVersion: Eclipse MicroProfile
endif::[]
:guidesBaseUrl: https://github.com/jboss-developer/jboss-developer-shared-resources/blob/master/guides/
:useEclipseUrl: {guidesBaseUrl}USE_JBDS.adoc#use_red_hat_jboss_developer_studio_or_eclipse_to_run_the_quickstarts
:useEclipseDeployJavaClientDocUrl: {guidesBaseUrl}USE_JBDS.adoc#deploy_and_undeploy_a_quickstart_containing_server_and_java_client_projects
:useEclipseDeployEARDocUrl: {guidesBaseUrl}USE_JBDS.adoc#deploy_and_undeploy_a_quickstart_ear_project
:useProductHomeDocUrl: {guidesBaseUrl}USE_OF_{jbossHomeName}.adoc#use_of_product_home_and_jboss_home_variables
:configureMavenDocUrl: {guidesBaseUrl}CONFIGURE_MAVEN_JBOSS_EAP.adoc#configure_maven_to_build_and_deploy_the_quickstarts
:addUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#create_users_required_by_the_quickstarts
:addApplicationUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#add_an_application_user
:addManagementUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#add_an_management_user
:startServerDocUrl: {guidesBaseUrl}START_JBOSS_EAP.adoc#start_the_jboss_eap_server
:configurePostgresDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#configure_the_postgresql_database_for_use_with_the_quickstarts
:configurePostgresDownloadDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#download_and_install_postgresql
:configurePostgresCreateUserDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#create_a_database_user
:configurePostgresAddModuleDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#add_the_postgres_module_to_the_jboss_eap_server
:configurePostgresDriverDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#configure_the_postgresql_driver_in_the_jboss_eap_server
:configureBytemanDownloadDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#download_and_configure_byteman
:configureBytemanDisableDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#disable_the_byteman_script
:configureBytemanClearDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#clear_the_transaction_object_store
:configureBytemanQuickstartDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#configure_byteman_for_use_with_the_quickstarts
:configureBytemanHaltDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#use_byteman_to_halt_the_application[
:configureBytemanQuickstartsDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#configure_byteman_for_use_with_the_quickstarts

= todo-backend: quickstart for backend deployment on OpenShift
:toc:               left
:icons:             font
:idprefix:
:idseparator:       -
:keywords:          openshift,galleon,helm
:level:             Intermediate
:technologies:      JPA, Jakarta REST, OpenShift, Galleon
:openshift: true
:archiveType: war
:useHelmChartDir: true
:helm-install-prerequisites-openshift: ../todo-backend/helm-install-prerequisites.adoc
:helm-install-prerequisites-kubernetes: ../todo-backend/helm-install-prerequisites.adoc
:helmSetWildFlyArgumentPrefix: wildfly.

[abstract]
The `todo-backend` quickstart demonstrates how to implement a backend that exposes a HTTP API with Jakarta REST
to manage a list of ToDo which are persisted in a database with JPA.

ifndef::ProductRelease[]
This quickstart shows how to setup a local deployment of this backend as well as a deployment on OpenShift to connect
to a PostgreSQL database also hosted on OpenShift.
endif::[]
ifdef::ProductRelease[]
This quickstart shows how to deploy a {productName} application on OpenShift that connects
to a PostgreSQL database also hosted on OpenShift.
endif::[]


== What is it?

The `todo-backend` quickstart demonstrates how to implement a backend that exposes a HTTP API with `Jakarta REST`
to manage a list of ToDo which are persisted in a database with `JPA`.

* The backend exposes a HTTP API to manage a list of todos that complies with the specs defined at https://todobackend.com/specs/index.html[todobackend.com].
* It requires a connection to a PostgreSQL database to persist the todos.
ifndef::ProductRelease[]
* It uses the Server Provisioning for local and cloud deployment
endif::[]
* It can be build with {productName} S2I images for cloud deployment
ifndef::ProductRelease[]
* It is deployed on OpenShift using the https://docs.wildfly.org/wildfly-charts/[Helm Chart for {productName}].
endif::[]
ifdef::ProductRelease[]
* It is deployed on OpenShift using the https://jbossas.github.io/eap-charts//[Helm Chart for {productName}].
endif::[]

// Link to the quickstart source
:leveloffset: +1

ifndef::ProductRelease,EAPXPRelease[]
link:https://github.com/wildfly/quickstart/tree/{WildFlyQuickStartRepoTag}/{artifactId}[Browse the source]
endif::[]

:leveloffset!:
// System Requirements
:leveloffset: +1

[[system_requirements]]
= System Requirements
//******************************************************************************
// Include this template to describe the standard system requirements for
// running the quickstarts.
//
// The Forge quickstarts define a `forge-from-scratch` attribute because they
// run entirely in CodeReady Studio and have different requirements .
//******************************************************************************

The application this project produces is designed to be run on {productNameFull} {productVersion} or later.

All you need to build this project is {buildRequirements}. See link:{configureMavenDocUrl}[Configure Maven to Build and Deploy the Quickstarts] to make sure you are configured correctly for testing the quickstarts.

:leveloffset!:

== Architecture

=== Architecture with S2I

This backend is built using {productName} S2I Builder and Runtime images.

ifndef::ProductRelease[]
When the image is built, `org.wildfly.plugins:wildfly-maven-plugin` plugin provisions the {productName} application server and all the feature packs it needs for its features.
The layers are defined in the `pom.xml` file in the `<configuration>` section of the `org.wildfly.plugins:wildfly-maven-plugin` plugin:

[source,xml]
----
<layers>
  <layer>cloud-server</layer>
  <layer>postgresql-datasource</layer>
</layers>
----
endif::[]

ifdef::ProductRelease[]
When the image is built, `org.jboss.eap.plugins:eap-maven-plugin` plugin provisions the {productName} application server and all the feature packs it needs for its features.
The layers are defined in the `pom.xml` file in the `<configuration>` section of the `org.jboss.eap.plugins:eap-maven-plugin` plugin:

[source,xml]
----
<layers>
  <layer>cloud-server</layer>
  <layer>postgresql-datasource</layer>
</layers>
----
endif::[]

The `cloud-server` layer provides everything needed to run the backend on OpenShift. This also includes access to
Jakarta EE APIs such as CDI, Jakarta REST, JPA, etc. These two layers comes from the {productName} feature pack provided in the
{productName} S2I builder image.

ifndef::ProductRelease[]
The `postgresql-datasource` layer provides a JDBC driver and DataSource to connect to a PostgreSQL database. It is also provided by
`org.wildfly:wildfly-datasources-galleon-pack` which is included in the WildFly S2I image.

The Git repository for this feature pack is hosted at https://github.com/wildfly-extras/wildfly-datasources-galleon-pack.
It provides JDBC drivers and datasources for different databases but for this quickstart, we will only need the `postgresql-datasource`.
endif::[]

ifdef::ProductRelease[]
The `postgresql-datasource` layer provides a JDBC driver and DataSource to connect to a PostgreSQL database. It is also provided by
the `org.jboss.eap:eap-datasources-galleon-pack` feature pack.

The Git repository for this feature pack is hosted at https://github.com/jbossas/eap-datasources-galleon-pack.
It provides JDBC drivers and datasources for different databases but for this quickstart, we will only need the `postgresql-datasource`.
endif::[]

=== Connection to the PostgreSQL database

ifndef::ProductRelease[]
As mentioned, the JDBC drivers and datasource configuration that the backend uses to connect to the PostgreSQL database
is provided by the `org.wildfly:wildfly-datasources-galleon-pack` feature pack.
endif::[]
ifdef::ProductRelease[]
As mentioned, the JDBC drivers and datasource configuration that the backend uses to connect to the PostgreSQL database
is provided by the `org.jboss.eap:eap-datasources-galleon-pack` feature pack.
endif::[]

By default, it exposes a single datasource.
In the backend, the name of this datasource is `ToDos` and is specified in the `persistence.xml` to configure JPA:

[source,xml]
----
<persistence-unit name="primary">
  <jta-data-source>java:jboss/datasources/ToDos</jta-data-source>
</persistence-unit>
----

At runtime, we only need a few environment variables to establish the connection from {productName} to the external PostgreSQL database:

* `POSTGRESQL_DATABASE` - the name of the database (that will be called `todos`)
* `POSTGRESQL_SERVICE_HOST` - the host to connect to the database
* `POSTGRESQL_SERVICE_PORT` - The port to connect to the database
* `POSTGRESQL_USER` & `POSTGRESQL_PASSWORD` - the credentials to connect to the database
* `POSTGRESQL_DATASOURCE` - The name of the datasources (as mentioned above, it will be `ToDos`)

=== Filters for Cross-Origin Resource Sharing (CORS)

The Web frontend for this quickstart uses JavaScript calls to query the backend's HTTP API.
We must enable Cross-Origin Resource Sharing (CORS) filters in the `undertow` subsystem of {productName} to allow
these HTTP requests to succeed.

ifdef::ProductRelease[]
==== Configuration with {productName} S2I

As we use S2I to provision the server and build the application, we provide a CLI script that contains all the commands to create and configure the CORS filters in Undertow. This script is located in the `src/scripts/cors_filters.cli`.
endif::[]

This script is executed at build time and will provide the following HTTP headers to enabled CORS:

* `Access-Control-Allow-Origin: *`
* `Access-Control-Allow-Methods: GET, POST, OPTION, PUT, DELETE, PATCH`
* `Access-Control-Allow-Headers: accept, authorization, content-type, x-requested-with`
* `Access-Control-Allow-Credentials: true`
* `Access-Control-Max-Age: 1`

By default, the backend accepts requests from any origin (`*`). This is only simplicity. It is possible to restrict
the allowed origin using the environment variable `CORS_ORIGIN` at runtime.

== Run the Backend Locally

=== Package the Backend

The backend is packaged and deployed on a provisioned server:

[source,options="nowrap"]
----
$ mvn clean package
----

=== Run a Local PostgreSQL Database

Before running the backend locally, we need to have a local PostgreSQL database that we can connect to.
We use the `postgresql` docker image to create one:

[source,options="nowrap"]
----
$ docker run --name todo-backend-db -e POSTGRES_USER=todos -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres
----

This will create a database named `todos` that we can connect to on `localhost:5432` with the credentials `todos / mysecretpassword`.

=== Run the Application

With the PostgreSQL database running, we can start the backend by passing the required environment variables to connect to the database:

[source,options="nowrap"]
----
$ ./target/server/bin/standalone.sh -Denv.POSTGRESQL_DATABASE=todos -Denv.POSTGRESQL_DATASOURCE=ToDos -Denv.POSTGRESQL_SERVICE_HOST=localhost -Denv.POSTGRESQL_SERVICE_PORT=5432 -Denv.POSTGRESQL_USER=todos -Denv.POSTGRESQL_PASSWORD=mysecretpassword
----

The backend is running, and we can use the HTTP API to manage a list of todos:

[source,options="nowrap"]
----
# get a list of todos
$ curl http://localhost:8080/todo-backend
[]

# create a todo with the title "This is my first todo item!"
$ curl -X POST -H "Content-Type: application/json"  -d '{"title": "This is my first todo item!"}' http://localhost:8080/todo-backend
{"completed":false,"id":1,"order":0,"title":"This is my first todo item!","url":"https://localhost:8080/1"}%

# get a list of todos with the one that was just created
$ curl http://localhost:8080/todo-backend
[{"completed":false,"id":1,"order":0,"title":"This is my first todo item!","url":"https://localhost:8080/1"}]
----

Please note that the quickstart includes integration tests, which may be executed using the following command:

[source,subs="attributes+",options="nowrap"]
----
$ mvn verify -Pintegration-testing
----

//===========================================================
// Openshift - START
== Run the Backend on OpenShift

// OpenShift
:leveloffset: +1

:cloud-platform: OpenShift
:openshift: true
ifndef::helm-app-name[]
:helm-app-name: {artifactId}
endif::helm-app-name[]

[[build_and_run_the_quickstart_on_openshift]]
= Building and running the quickstart application with OpenShift
// The openshift profile
:leveloffset: +1

[[build-the-quickstart-for-openshift]]
== Build the {productName} Source-to-Image (S2I) Quickstart to {cloud-platform} with Helm Charts

On OpenShift, the S2I build with Apache Maven uses an `openshift` Maven profile to provision a {productName} server, deploy and run the quickstart in OpenShift environment.

ifndef::ProductRelease[]
The server provisioning functionality is provided by the WildFly Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
[source,xml,subs="attributes+"]
----
<profile>
    <id>openshift</id>
    <build>
        <plugins>
            <plugin>
                <groupId>org.wildfly.plugins</groupId>
                <artifactId>wildfly-maven-plugin</artifactId>
                <configuration>
                    <discover-provisioning-info>
                        <version>${version.server}</version>
                        <context>cloud</context>
                    </discover-provisioning-info>
                    <add-ons>...</add-ons>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>package</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            ...
        </plugins>
    </build>
</profile>
----
You may note that unlike the `provisioned-server` profile it uses the cloud context which enables a configuration tuned for {cloud-platform} environment.
endif::[]

ifdef::ProductRelease[]
ifndef::EAPXPRelease[:featurePackLocation: org.jboss.eap:wildfly-ee-galleon-pack]
ifdef::EAPXPRelease[:featurePackLocation: org.jboss.eap.xp:wildfly-galleon-pack]
The server provisioning functionality is provided by the EAP Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
[source,xml,subs="attributes+"]
----
<profile>
    <id>openshift</id>
    <build>
        <plugins>
            <plugin>
                <groupId>org.jboss.eap.plugins</groupId>
                <artifactId>eap-maven-plugin</artifactId>
                <configuration>
                    ...
                    <feature-packs>
                        <feature-pack>
                            <location>{featurePackLocation}</location>
                        </feature-pack>
                        <feature-pack>
                            <location>org.jboss.eap.cloud:eap-cloud-galleon-pack</location>
                        </feature-pack>
                    </feature-packs>
                    <layers>...</layers>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>package</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            ...
        </plugins>
    </build>
</profile>
----
You may note that it uses the cloud feature pack which enables a configuration tuned for the {cloud-platform} environment.
endif::[]

:leveloffset: 1
// Getting Started with Helm
:leveloffset: +1

[[getting_started_with_helm]]
= Getting Started with {xpaasproduct-shortname} and Helm Charts

This section contains the basic instructions to build and deploy this quickstart to {xpaasproduct-shortname} using Helm Charts.

[[prerequisites_helm_openshift]]
== Prerequisites

ifndef::kubernetes[]
* You must be logged in OpenShift and have an `oc` client to connect to OpenShift
endif::[]
* https://helm.sh[Helm] must be installed to deploy the backend on {cloud-platform}.

Once you have installed Helm, you need to add the repository that provides Helm Charts for {ProductShortName}.

ifndef::ProductRelease[]
[source,options="nowrap"]
----
$ helm repo add wildfly https://docs.wildfly.org/wildfly-charts/
"wildfly" has been added to your repositories
$ helm search repo wildfly
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
wildfly/wildfly         ...             ...            Build and Deploy WildFly applications on OpenShift
wildfly/wildfly-common  ...             ...            A library chart for WildFly-based applications
----
endif::[]
ifdef::ProductRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP applications
----
endif::[]

:leveloffset: 1

ifdef::helm-install-prerequisites-openshift[]
// Additional steps needed before deploying in Helm
[[deploy_helm_prerequisites]]
:leveloffset: +1

ifndef::ProductRelease[]
The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I.
It also deploys the PostGreSQL database to store the data.

[source,options="nowrap"]
----
dependencies:
    - name: wildfly
      repository: http://docs.wildfly.org/wildfly-charts/
      version: ...
----

So we need to update the dependencies of our Helm Chart.

[source,options="nowrap",subs="+attributes"]
----
$ helm dependency update charts/
----
endif::[]

:leveloffset: 1
endif::helm-install-prerequisites-openshift[]

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

ifndef::helmSetWildFlyArgumentPrefix[]
// For use with nested Helm charts
:helmSetWildFlyArgumentPrefix:
endif::[]
ifeval::[{useHelmChartDir} == true]
:helm_chart_values: charts
endif::[]
ifndef::useHelmChartDir[]
:helm_chart_values: -f charts/helm.yaml {helmChartName}
endif::[]
ifdef::kubernetes[]
:helm-set-build-enabled: --set {helmSetWildFlyArgumentPrefix}build.enabled=false
:helm-set-deploy-route-enabled: --set {helmSetWildFlyArgumentPrefix}deploy.route.enabled=false
:helm-set-image-name: --set {helmSetWildFlyArgumentPrefix}image.name="localhost:5000/{artifactId}"
:helm-extra-arguments: {helm-set-build-enabled} {helm-set-deploy-route-enabled} {helm-set-image-name}
:cloud-cli: kubectl
endif::[]
ifndef::kubernetes[]
:helm-extra-arguments:
:cloud-cli: oc
endif::[]
[[deploy_helm]]
== Deploy the {ProductShortName} Source-to-Image (S2I) Quickstart to {cloud-platform} with Helm Charts

ifndef::kubernetes[]
Log in to your OpenShift instance using the `oc login` command.
endif::[]
The backend will be built and deployed on {cloud-platform} with a Helm Chart for {ProductShortName}.


ifndef::kubernetes[]
Navigate to the root directory of this quickstart and run the following command:
endif::[]
ifdef::kubernetes[]
Navigate to the root directory of this quickstart and run the following commands:

[source,options="nowrap",subs="+attributes"]
----
mvn -Popenshift package wildfly:image
----
This will use the `openshift` Maven profile we saw earlier to build the application, and create a Docker image containing the {productName} server with the application deployed. The name of the image will be `{artifactId}`.

Next we need to tag the image and make it available to Kubernetes. You can push it to a registry like `quay.io`. In this case we tag as `localhost:5000/{artifactId}:latest` and push it to the internal registry in our Kubernetes instance:

[source,options="nowrap",subs="+attributes"]
----
# Tag the image
docker tag {artifactId} localhost:5000/{artifactId}:latest
# Push the image to the registry
docker push localhost:5000/{artifactId}:latest
----

In the below call to `helm install` which deploys our application to Kubernetes, we are passing in some extra arguments to tweak the Helm build:

* `{helm-set-build-enabled}` - This turns off the s2i build for the Helm chart since Kubernetes, unlike OpenShift, does not have s2i. Instead, we are providing the image to use.
* `{helm-set-deploy-route-enabled}` - This disables route creation normally performed by the Helm chart. On Kubernetes we will use port-forwards instead to access our application, since routes are an OpenShift specific concept and thus not available on Kubernetes.
* `{helm-set-image-name}` - This tells the Helm chart to use the image we built, tagged and pushed to Kubernetes' internal registry above.

endif::[]
[source,options="nowrap",subs="+attributes"]
----
$ helm install {helm-app-name} {helm_chart_values} --wait --timeout=10m0s {helm-extra-arguments}
NAME: {helm-app-name}
...
STATUS: deployed
REVISION: 1
----

This command will return once the application has successfully deployed. In case of a timeout, you can check the status of the application with the following command in another terminal:

[source,options="nowrap",subs="+attributes"]
----
{cloud-cli} get deployment {helm-app-name}
----

The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I on Java 17:


ifndef::requires-http-route[]
ifdef::useHelmChartDir[]
[source,yaml]
----
apiVersion: v2
name: todo-backend-chart
description: A Helm chart to deploy a WildFly todo-backend application and its Postgresql database
type: application
version: 1.0.0
dependencies:
    - name: wildfly
      repository: http://docs.wildfly.org/wildfly-charts/
      version: 2.3.2
----
endif::useHelmChartDir[]
ifndef::useHelmChartDir[]
[source,yaml]
----
include::{docdir}/charts/helm.yaml[]
----
endif::useHelmChartDir[]
endif::requires-http-route[]

ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
build:
  uri: {githubRepoCodeUrl}
  ref: {WildFlyQuickStartRepoTag}
  contextDir: {artifactId}
deploy:
  replicas: 1
  route:
    tls:
      enabled: false
----
endif::requires-http-route[]

This will create a new deployment on {cloud-platform} and deploy the application.

If you want to see all the configuration elements to customize your deployment you can use the following command:
[source,options="nowrap",subs="+attributes"]
----
$ helm show readme {helmChartName}
----

ifdef::openshift[]
Get the URL of the route to the deployment.

[source,options="nowrap",subs="+attributes"]
----
$ oc get route {helm-app-name} -o jsonpath="{.spec.host}"
----
Access the application in your web browser using the displayed URL.
endif::[]
ifdef::kubernetes[]
To be able to connect to our application running in Kubernetes from outside, we need to set up a port-forward to the `{helm-app-name}` service created for us by the Helm chart.

This service will run on port `8080`, and we set up the port forward to also run on port `8080`:

[source,options="nowrap",subs="+attributes"]
----
kubectl port-forward service/{helm-app-name} 8080:8080
----
The server can now be accessed via `http://localhost:8080` from outside Kubernetes. Note that the command to create the port-forward will not return, so it is easiest to run this in a separate terminal.

endif::[]

ifdef::openshift+post-helm-install-actions-openshift[]
include::{post-helm-install-actions-openshift}[leveloffset=+1]
endif::openshift+post-helm-install-actions-openshift[]
ifdef::kubernetes+post-helm-install-actions-kubernetes[]
include::{post-helm-install-actions-kubernetes}[leveloffset=+1]
endif::kubernetes+post-helm-install-actions-kubernetes[]

:leveloffset: 1

// Testing on Openshift
:leveloffset: +1

[[run_the_integration_tests_with_openshift]]
= Run the Integration Tests with OpenShift
The integration tests included with this quickstart, which verify that the quickstart runs correctly, may also be run with the quickstart running on OpenShift.
[NOTE]
====
The integration tests expect a deployed application, so make sure you have deployed the quickstart on OpenShift before you begin.
====

ifdef::extra-testing-actions-openshift[]
include::{extra-testing-actions-openshift}[leveloffset=+1]
endif::extra-testing-actions-openshift[]

ifndef::extra-test-arguments-openshift[:extra-test-arguments-openshift:]

Run the integration tests using the following command to run the `verify` goal with the `integration-testing` profile activated and the proper URL:
ifndef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=https://$(oc get route {helm-app-name} --template='{{ .spec.host }}') {extra-test-arguments-openshift}
----
endif::requires-http-route[]
ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=http://$(oc get route {helm-app-name} --template='{{ .spec.host }}') {extra-test-arguments-openshift}
----
endif::requires-http-route[]

[NOTE]
====
The tests are using SSL to connect to the quickstart running on OpenShift. So you need the certificates to be trusted by the machine the tests are run from.
====

:leveloffset: 1

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

[[undeploy_helm]]
== Undeploy the {ProductShortName} Source-to-Image (S2I) Quickstart from {cloud-platform} with Helm Charts

[source,options="nowrap",subs="+attributes"]
----
$ helm uninstall {helm-app-name}
----
ifdef::kubernetes[]
To stop the port forward you created earlier use:
[source,options="nowrap",subs="+attributes"]
----
$ kubectl port-forward service/{helm-app-name} 8080:8080
----
endif::[]

:leveloffset: 1

// Unset the attribute
:!openshift:

:leveloffset!:
:leveloffset: +1

:additional-readme-openshift: true
ifdef::additional-readme-openshift[]
:additional-readme-cloud-platform: OpenShift
endif::[]
ifdef::additional-readme-kubernetes[]
:additional-readme-cloud-platform: Kubernetes
endif::[]

=== Environment variables for PostgreSQL

The Helm Chart also contains the environment variables required to connect to the PostgreSQL database.

ifndef::ProductRelease[]
In local deployment the credentials were passed directly as the values of the environment variables.
endif::[]

For {additional-readme-cloud-platform}, we rely on secrets so that the credentials are never copied outside {additional-readme-cloud-platform}:

[source,options="nowrap"]
----
deploy:
  env:
    - name: POSTGRESQL_PASSWORD
        - name: POSTGRESQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: postgres-configmap
              key: POSTGRES_PASSWORD
----

When the application is deployed, the value for the `POSTGRESQL_PASSWORD` will be taken from the key `POSTGRES_PASSWORD`
in the secret `postgres-configmap`.

ifdef::additional-readme-openshift[]
== Use the todobackend Web Frontend

Once the backend is deployed on {additional-readme-cloud-platform}, it can be accessed from the route `todo-backend`.
Let's find the host that we can use to connect to this backend:

[source,options="nowrap"]
----
$ oc get route todo-backend -o jsonpath="{.spec.host}"
todo-backend-jmesnil1-dev.apps.sandbox.x8i5.p1.openshiftapps.com
----

This value will be different for every installation of the backend.

To be able to connect to the backend from the ToDo Backend Specs or Client, then prepend the host with `https://`, and append the relative web context `/todo-backend`. For the previous example host this would be `https://todo-backend-jmesnil1-dev.apps.sandbox.x8i5.p1.openshiftapps.com/todo-backend`.

We can verify that this application is properly working as a ToDo Backend by running its https://todobackend.com/specs/index.html[specs] on it.

Once all tests passed, we can use the https://todobackend.com/client/index.html[todobackend client] to have a Web application connected to the backend.

[NOTE]
====
https://todobackend.com/[todobackend.com] is an external service used to showcase this quickstart.
It might not always be functional but does not impact the availability of this backend.
====
endif::[]

== Clean Up

=== Remove the Backend

The backend can be deleted from {additional-readme-cloud-platform} by running the command:

[source,options="nowrap"]
----
$ helm uninstall todo-backend
release "todo-backend" uninstalled
----
// Unset the attribute
:!additional-readme-openshift:

:leveloffset!:
// OpenShift - END
//===========================================================

//===========================================================
// Kubernetes - START
ifndef::ProductRelease,EAPXPRelease[]
== Run the Backend on Kubernetes

//Kubernetes
:leveloffset: +1

:cloud-platform: Kubernetes
:kubernetes: true
ifndef::helm-app-name[]
:helm-app-name: {artifactId}
endif::helm-app-name[]

[[build_and_run_the_quickstart_on_kubernetes]]
= Building and running the quickstart application with Kubernetes
// The openshift profile
:leveloffset: +1

[[build-the-quickstart-for-kubernetes]]
== Build the {productName} Quickstart to Kubernetes with Helm Charts

For Kubernetes, the build with Apache Maven uses an `openshift` Maven profile to provision a {productName} server, suitable for running on Kubernetes.

ifndef::ProductRelease[]
The server provisioning functionality is provided by the WildFly Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
[source,xml,subs="attributes+"]
----
<profile>
    <id>openshift</id>
    <build>
        <plugins>
            <plugin>
                <groupId>org.wildfly.plugins</groupId>
                <artifactId>wildfly-maven-plugin</artifactId>
                <configuration>
                    <discover-provisioning-info>
                        <version>${version.server}</version>
                        <context>cloud</context>
                    </discover-provisioning-info>
                    <add-ons>...</add-ons>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>package</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            ...
        </plugins>
    </build>
</profile>
----
You may note that unlike the `provisioned-server` profile it uses the cloud context which enables a configuration tuned for {cloud-platform} environment.
endif::[]

ifdef::ProductRelease[]
ifndef::EAPXPRelease[:featurePackLocation: org.jboss.eap:wildfly-ee-galleon-pack]
ifdef::EAPXPRelease[:featurePackLocation: org.jboss.eap.xp:wildfly-galleon-pack]
The server provisioning functionality is provided by the EAP Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
[source,xml,subs="attributes+"]
----
<profile>
    <id>openshift</id>
    <build>
        <plugins>
            <plugin>
                <groupId>org.jboss.eap.plugins</groupId>
                <artifactId>eap-maven-plugin</artifactId>
                <configuration>
                    ...
                    <feature-packs>
                        <feature-pack>
                            <location>{featurePackLocation}</location>
                        </feature-pack>
                        <feature-pack>
                            <location>org.jboss.eap.cloud:eap-cloud-galleon-pack</location>
                        </feature-pack>
                    </feature-packs>
                    <layers>...</layers>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>package</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            ...
        </plugins>
    </build>
</profile>
----
You may note that it uses the cloud feature pack which enables a configuration tuned for the {cloud-platform} environment.
endif::[]

:leveloffset: 1
// Getting Started with Helm
:leveloffset: +1

[[getting_started_with_helm]]
= Getting Started with Kubernetes and Helm Charts

This section contains the basic instructions to build and deploy this quickstart to Kubernetes using Helm Charts.

== Install Kubernetes
In this example we are using https://github.com/kubernetes/minikube[Minikube] as our Kubernetes provider. See the https://minikube.sigs.k8s.io/docs/start/[Minikube Getting Started guide] for how to install it. After installing it, we start it with 4GB of memory.

[source,options="nowrap",subs="+attributes"]
----
minikube start --memory='4gb'
----
The above command should work if you have Docker installed on your machine. If, you are using https://podman-desktop.io[Podman] instead of Docker, you will also need to pass in `--driver=podman`, as covered in the https://minikube.sigs.k8s.io/docs/handbook/config/[Minikube documentation].

Once Minikube has started, we need to enable its https://minikube.sigs.k8s.io/docs/handbook/registry/[registry] since that is where we will push the image needed to deploy the quickstart, and where we will tell the Helm charts to download it from.

[source,options="nowrap",subs="+attributes"]
----
minikube addons enable registry
----

In order to be able to push images to the registry we need to make it accessible from outside Kubernetes. How we do this depends on your operating system. All the below examples will expose it at `localhost:5000`

[source,options="nowrap",subs="+attributes"]
----
# On Mac:
docker run --rm -it --network=host alpine ash -c "apk add socat && socat TCP-LISTEN:5000,reuseaddr,fork TCP:$(minikube ip):5000"

# On Linux:
kubectl port-forward --namespace kube-system service/registry 5000:80 &

# On Windows:
kubectl port-forward --namespace kube-system service/registry 5000:80
docker run --rm -it --network=host alpine ash -c "apk add socat && socat TCP-LISTEN:5000,reuseaddr,fork TCP:host.docker.internal:5000"
----

[[prerequisites_helm_openshift]]
== Prerequisites

ifndef::kubernetes[]
* You must be logged in OpenShift and have an `oc` client to connect to OpenShift
endif::[]
* https://helm.sh[Helm] must be installed to deploy the backend on {cloud-platform}.

Once you have installed Helm, you need to add the repository that provides Helm Charts for {ProductShortName}.

ifndef::ProductRelease[]
[source,options="nowrap"]
----
$ helm repo add wildfly https://docs.wildfly.org/wildfly-charts/
"wildfly" has been added to your repositories
$ helm search repo wildfly
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
wildfly/wildfly         ...             ...            Build and Deploy WildFly applications on OpenShift
wildfly/wildfly-common  ...             ...            A library chart for WildFly-based applications
----
endif::[]
ifdef::ProductRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP applications
----
endif::[]

:leveloffset: 1

ifdef::helm-install-prerequisites-kubernetes[]
// Additional steps needed before deploying in Helm
[[deploy_helm_prerequisites]]
:leveloffset: +1

ifndef::ProductRelease[]
The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I.
It also deploys the PostGreSQL database to store the data.

[source,options="nowrap"]
----
dependencies:
    - name: wildfly
      repository: http://docs.wildfly.org/wildfly-charts/
      version: ...
----

So we need to update the dependencies of our Helm Chart.

[source,options="nowrap",subs="+attributes"]
----
$ helm dependency update charts/
----
endif::[]

:leveloffset: 1
endif::helm-install-prerequisites-kubernetes[]

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

ifndef::helmSetWildFlyArgumentPrefix[]
// For use with nested Helm charts
:helmSetWildFlyArgumentPrefix:
endif::[]
ifeval::[{useHelmChartDir} == true]
:helm_chart_values: charts
endif::[]
ifndef::useHelmChartDir[]
:helm_chart_values: -f charts/helm.yaml {helmChartName}
endif::[]
ifdef::kubernetes[]
:helm-set-build-enabled: --set {helmSetWildFlyArgumentPrefix}build.enabled=false
:helm-set-deploy-route-enabled: --set {helmSetWildFlyArgumentPrefix}deploy.route.enabled=false
:helm-set-image-name: --set {helmSetWildFlyArgumentPrefix}image.name="localhost:5000/{artifactId}"
:helm-extra-arguments: {helm-set-build-enabled} {helm-set-deploy-route-enabled} {helm-set-image-name}
:cloud-cli: kubectl
endif::[]
ifndef::kubernetes[]
:helm-extra-arguments:
:cloud-cli: oc
endif::[]
[[deploy_helm]]
== Deploy the {ProductShortName} Source-to-Image (S2I) Quickstart to {cloud-platform} with Helm Charts

ifndef::kubernetes[]
Log in to your OpenShift instance using the `oc login` command.
endif::[]
The backend will be built and deployed on {cloud-platform} with a Helm Chart for {ProductShortName}.


ifndef::kubernetes[]
Navigate to the root directory of this quickstart and run the following command:
endif::[]
ifdef::kubernetes[]
Navigate to the root directory of this quickstart and run the following commands:

[source,options="nowrap",subs="+attributes"]
----
mvn -Popenshift package wildfly:image
----
This will use the `openshift` Maven profile we saw earlier to build the application, and create a Docker image containing the {productName} server with the application deployed. The name of the image will be `{artifactId}`.

Next we need to tag the image and make it available to Kubernetes. You can push it to a registry like `quay.io`. In this case we tag as `localhost:5000/{artifactId}:latest` and push it to the internal registry in our Kubernetes instance:

[source,options="nowrap",subs="+attributes"]
----
# Tag the image
docker tag {artifactId} localhost:5000/{artifactId}:latest
# Push the image to the registry
docker push localhost:5000/{artifactId}:latest
----

In the below call to `helm install` which deploys our application to Kubernetes, we are passing in some extra arguments to tweak the Helm build:

* `{helm-set-build-enabled}` - This turns off the s2i build for the Helm chart since Kubernetes, unlike OpenShift, does not have s2i. Instead, we are providing the image to use.
* `{helm-set-deploy-route-enabled}` - This disables route creation normally performed by the Helm chart. On Kubernetes we will use port-forwards instead to access our application, since routes are an OpenShift specific concept and thus not available on Kubernetes.
* `{helm-set-image-name}` - This tells the Helm chart to use the image we built, tagged and pushed to Kubernetes' internal registry above.

endif::[]
[source,options="nowrap",subs="+attributes"]
----
$ helm install {helm-app-name} {helm_chart_values} --wait --timeout=10m0s {helm-extra-arguments}
NAME: {helm-app-name}
...
STATUS: deployed
REVISION: 1
----

This command will return once the application has successfully deployed. In case of a timeout, you can check the status of the application with the following command in another terminal:

[source,options="nowrap",subs="+attributes"]
----
{cloud-cli} get deployment {helm-app-name}
----

The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I on Java 17:


ifndef::requires-http-route[]
ifdef::useHelmChartDir[]
[source,yaml]
----
apiVersion: v2
name: todo-backend-chart
description: A Helm chart to deploy a WildFly todo-backend application and its Postgresql database
type: application
version: 1.0.0
dependencies:
    - name: wildfly
      repository: http://docs.wildfly.org/wildfly-charts/
      version: 2.3.2
----
endif::useHelmChartDir[]
ifndef::useHelmChartDir[]
[source,yaml]
----
include::{docdir}/charts/helm.yaml[]
----
endif::useHelmChartDir[]
endif::requires-http-route[]

ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
build:
  uri: {githubRepoCodeUrl}
  ref: {WildFlyQuickStartRepoTag}
  contextDir: {artifactId}
deploy:
  replicas: 1
  route:
    tls:
      enabled: false
----
endif::requires-http-route[]

This will create a new deployment on {cloud-platform} and deploy the application.

If you want to see all the configuration elements to customize your deployment you can use the following command:
[source,options="nowrap",subs="+attributes"]
----
$ helm show readme {helmChartName}
----

ifdef::openshift[]
Get the URL of the route to the deployment.

[source,options="nowrap",subs="+attributes"]
----
$ oc get route {helm-app-name} -o jsonpath="{.spec.host}"
----
Access the application in your web browser using the displayed URL.
endif::[]
ifdef::kubernetes[]
To be able to connect to our application running in Kubernetes from outside, we need to set up a port-forward to the `{helm-app-name}` service created for us by the Helm chart.

This service will run on port `8080`, and we set up the port forward to also run on port `8080`:

[source,options="nowrap",subs="+attributes"]
----
kubectl port-forward service/{helm-app-name} 8080:8080
----
The server can now be accessed via `http://localhost:8080` from outside Kubernetes. Note that the command to create the port-forward will not return, so it is easiest to run this in a separate terminal.

endif::[]

ifdef::openshift+post-helm-install-actions-openshift[]
include::{post-helm-install-actions-openshift}[leveloffset=+1]
endif::openshift+post-helm-install-actions-openshift[]
ifdef::kubernetes+post-helm-install-actions-kubernetes[]
include::{post-helm-install-actions-kubernetes}[leveloffset=+1]
endif::kubernetes+post-helm-install-actions-kubernetes[]

:leveloffset: 1

// Testing on Openshift
:leveloffset: +1

[[run_the_integration_tests_with_kubernetes]]
= Run the Integration Tests with Kubernetes
The integration tests included with this quickstart, which verify that the quickstart runs correctly, may also be run with the quickstart running on Kubernetes.
[NOTE]
====
The integration tests expect a deployed application, so make sure you have deployed the quickstart on Kubernetes before you begin.
====

ifdef::extra-testing-actions-kubernetes[]
include::{extra-testing-actions-kubernetes}[leveloffset=+1]
endif::extra-testing-actions-kubernetes[]

ifndef::extra-test-arguments-kubernetes[:extra-test-arguments-kubernetes:]

Run the integration tests using the following command to run the `verify` goal with the `integration-testing` profile activated and the proper URL:
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=http://localhost:8080 {extra-test-arguments-kubernetes}
----


:leveloffset: 1

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

[[undeploy_helm]]
== Undeploy the {ProductShortName} Source-to-Image (S2I) Quickstart from {cloud-platform} with Helm Charts

[source,options="nowrap",subs="+attributes"]
----
$ helm uninstall {helm-app-name}
----
ifdef::kubernetes[]
To stop the port forward you created earlier use:
[source,options="nowrap",subs="+attributes"]
----
$ kubectl port-forward service/{helm-app-name} 8080:8080
----
endif::[]

:leveloffset: 1

// Unset the attribute
:!kubernetes:

:leveloffset!:
:leveloffset: +1

:additional-readme-kubernetes: true
ifdef::additional-readme-openshift[]
:additional-readme-cloud-platform: OpenShift
endif::[]
ifdef::additional-readme-kubernetes[]
:additional-readme-cloud-platform: Kubernetes
endif::[]

=== Environment variables for PostgreSQL

The Helm Chart also contains the environment variables required to connect to the PostgreSQL database.

ifndef::ProductRelease[]
In local deployment the credentials were passed directly as the values of the environment variables.
endif::[]

For {additional-readme-cloud-platform}, we rely on secrets so that the credentials are never copied outside {additional-readme-cloud-platform}:

[source,options="nowrap"]
----
deploy:
  env:
    - name: POSTGRESQL_PASSWORD
        - name: POSTGRESQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: postgres-configmap
              key: POSTGRES_PASSWORD
----

When the application is deployed, the value for the `POSTGRESQL_PASSWORD` will be taken from the key `POSTGRES_PASSWORD`
in the secret `postgres-configmap`.

ifdef::additional-readme-openshift[]
== Use the todobackend Web Frontend

Once the backend is deployed on {additional-readme-cloud-platform}, it can be accessed from the route `todo-backend`.
Let's find the host that we can use to connect to this backend:

[source,options="nowrap"]
----
$ oc get route todo-backend -o jsonpath="{.spec.host}"
todo-backend-jmesnil1-dev.apps.sandbox.x8i5.p1.openshiftapps.com
----

This value will be different for every installation of the backend.

To be able to connect to the backend from the ToDo Backend Specs or Client, then prepend the host with `https://`, and append the relative web context `/todo-backend`. For the previous example host this would be `https://todo-backend-jmesnil1-dev.apps.sandbox.x8i5.p1.openshiftapps.com/todo-backend`.

We can verify that this application is properly working as a ToDo Backend by running its https://todobackend.com/specs/index.html[specs] on it.

Once all tests passed, we can use the https://todobackend.com/client/index.html[todobackend client] to have a Web application connected to the backend.

[NOTE]
====
https://todobackend.com/[todobackend.com] is an external service used to showcase this quickstart.
It might not always be functional but does not impact the availability of this backend.
====
endif::[]

== Clean Up

=== Remove the Backend

The backend can be deleted from {additional-readme-cloud-platform} by running the command:

[source,options="nowrap"]
----
$ helm uninstall todo-backend
release "todo-backend" uninstalled
----
// Unset the attribute
:!additional-readme-kubernetes:

:leveloffset!:
endif::[]
// Kubernetes - END
//===========================================================


== Conclusion

This quickstart shows how the datasource feature pack provided by {productName} simplifies the deployment
of a {productName} Jakarta EE backend on OpenShift to connect to an external database and exposes an HTTP API.

The use of a Server Provisioned deployment makes it seamless to move from a local deployment for development to a
deployment on cloud platforms such as OpenShift and Kubernetes.
