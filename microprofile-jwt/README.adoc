ifdef::env-github[]
:artifactId: microprofile-jwt
endif::[]

//***********************************************************************************
// Enable the following flag to build README.html files for JBoss EAP product builds.
// Comment it out for WildFly builds.
//***********************************************************************************
//:ProductRelease:

//***********************************************************************************
// Enable the following flag to build README.html files for EAP XP product builds.
// Comment it out for WildFly or JBoss EAP product builds.
//***********************************************************************************
//:EAPXPRelease:

// This is a universal name for all releases
:ProductShortName: JBoss EAP
// Product names and links are dependent on whether it is a product release (CD or JBoss)
// or the WildFly project.
// The "DocInfo*" attributes are used to build the book links to the product documentation

ifdef::ProductRelease[]
// JBoss EAP release
:productName: JBoss EAP
:productNameFull: Red Hat JBoss Enterprise Application Platform
:productVersion: 8.0
:DocInfoProductNumber: {productVersion}
:WildFlyQuickStartRepoTag: 8.0.x
:productImageVersion: 8.0.0
:helmChartName: jboss-eap/eap8
endif::[]

ifdef::EAPXPRelease[]
// JBoss EAP XP release
:productName: JBoss EAP XP
:productNameFull: Red Hat JBoss Enterprise Application Platform expansion pack
:productVersion: 5.0
:DocInfoProductNumber: 8.0
:WildFlyQuickStartRepoTag: XP_5.0.0.GA
:productImageVersion: 5.0
:helmChartName: jboss-eap/eap-xp5
endif::[]

ifdef::ProductRelease,EAPXPRelease[]
:githubRepoUrl: https://github.com/jboss-developer/jboss-eap-quickstarts/
:githubRepoCodeUrl: https://github.com/jboss-developer/jboss-eap-quickstarts.git
:jbossHomeName: EAP_HOME
:DocInfoProductName: Red Hat JBoss Enterprise Application Platform
:DocInfoProductNameURL: red_hat_jboss_enterprise_application_platform
:DocInfoPreviousProductName: jboss-enterprise-application-platform
:quickstartDownloadName: {productNameFull} {productVersion} Quickstarts
:quickstartDownloadUrl: https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=appplatform&downloadType=distributions
:helmRepoName: jboss-eap
:helmRepoUrl: https://jbossas.github.io/eap-charts/
// END ifdef::ProductRelease,EAPXPRelease[]
endif::[]

ifndef::ProductRelease,EAPXPRelease[]
// WildFly project
:productName: WildFly
:productNameFull: WildFly Application Server
:ProductShortName: {productName}
:jbossHomeName: WILDFLY_HOME
:productVersion: 35
:productImageVersion: 35.0
:githubRepoUrl: https://github.com/wildfly/quickstart/
:githubRepoCodeUrl: https://github.com/wildfly/quickstart.git
:WildFlyQuickStartRepoTag: 35.0.0.Final
:DocInfoProductName: Red Hat JBoss Enterprise Application Platform
:DocInfoProductNameURL: red_hat_jboss_enterprise_application_platform
:DocInfoProductNumber: 8.0
:DocInfoPreviousProductName: jboss-enterprise-application-platform
:helmRepoName: wildfly
:helmRepoUrl: http://docs.wildfly.org/wildfly-charts/
:helmChartName: wildfly/wildfly
// END ifndef::ProductRelease,EAPCDRelease,EAPXPRelease[]
endif::[]

:source: {githubRepoUrl}

// Values for Openshift S2i sections attributes
:CDProductName:  {productNameFull} for OpenShift
:CDProductShortName: {ProductShortName} for OpenShift
:CDProductTitle: {CDProductName}
:CDProductNameSentence: Openshift release for {ProductShortName}
:CDProductAcronym: {CDProductShortName}
:CDProductVersion: {productVersion}
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {EapForOpenshiftBookName} Online
:xpaasproduct: {productNameFull} for OpenShift
:xpaasproductOpenShiftOnline: {xpaasproduct} Online
:xpaasproduct-shortname: {CDProductShortName}
:xpaasproductOpenShiftOnline-shortname: {xpaasproduct-shortname} Online
:ContainerRegistryName: Red Hat Container Registry
:EapForOpenshiftBookName: Getting Started with {ProductShortName} for OpenShift Container Platform
:EapForOpenshiftOnlineBookName: Getting Started with {ProductShortName} for OpenShift Online
:OpenShiftOnlinePlatformName: Red Hat OpenShift Container Platform
:OpenShiftOnlineName: Red Hat OpenShift Online
:ImagePrefixVersion: eap80
:ImageandTemplateImportBaseURL: https://raw.githubusercontent.com/jboss-container-images/jboss-eap-openshift-templates
:ImageandTemplateImportURL: {ImageandTemplateImportBaseURL}/{ImagePrefixVersion}/
:BuildImageStream: jboss-{ImagePrefixVersion}-openjdk11-openshift
:RuntimeImageStream: jboss-{ImagePrefixVersion}-openjdk11-runtime-openshift

// OpenShift repository and reference for quickstarts
:EAPQuickStartRepo: https://github.com/jboss-developer/jboss-eap-quickstarts
:EAPQuickStartRepoRef: 8.0.x
:EAPQuickStartRepoTag: EAP_8.0.0.GA
// Links to the OpenShift documentation
:LinkOpenShiftGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_with_jboss_eap_for_openshift_container_platform/
:LinkOpenShiftOnlineGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_with_jboss_eap_for_openshift_online/

ifdef::EAPXPRelease[]
// Attributes for XP releases
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {productNameFull} for OpenShift Online
:xpaasproduct: {productNameFull} for OpenShift
:xpaasproductOpenShiftOnline: {productNameFull} for OpenShift Online
:xpaasproduct-shortname: {ProductShortName} for OpenShift
:xpaasproductOpenShiftOnline-shortname: {ProductShortName} for OpenShift Online
:ContainerRegistryName: Red Hat Container Registry
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {productNameFull} for OpenShift Online
:ImagePrefixVersion: eap-xp3
:ImageandTemplateImportURL: {ImageandTemplateImportBaseURL}/{ImagePrefixVersion}/
:BuildImageStream: jboss-{ImagePrefixVersion}-openjdk11-openshift
:RuntimeImageStream: jboss-{ImagePrefixVersion}-openjdk11-runtime-openshift
// OpenShift repository and reference for quickstarts
:EAPQuickStartRepoRef: xp-5.0.x
// Links to the OpenShift documentation
:LinkOpenShiftGuide: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/{DocInfoProductNumber}/html/using_eclipse_microprofile_in_jboss_eap/using-the-openshift-image-for-jboss-eap-xp_default
:LinkOpenShiftOnlineGuide: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/{DocInfoProductNumber}/html/using_eclipse_microprofile_in_jboss_eap/using-the-openshift-image-for-jboss-eap-xp_default
endif::[]

ifndef::ProductRelease,EAPCDRelease,EAPXPRelease[]
:ImageandTemplateImportURL: https://raw.githubusercontent.com/wildfly/wildfly-s2i/v{productVersion}.0/
endif::[]

//*************************
// Other values
//*************************
:buildRequirements: Java SE 17.0 or later, and Maven 3.6.0 or later
:jbdsEapServerName: Red Hat JBoss Enterprise Application Platform 8.0
:javaVersion: Jakarta EE 10
ifdef::EAPXPRelease[]
:javaVersion: Eclipse MicroProfile
endif::[]
:githubRepoBranch: master
:guidesBaseUrl: https://github.com/jboss-developer/jboss-developer-shared-resources/blob/master/guides/
:useEclipseUrl: {guidesBaseUrl}USE_JBDS.adoc#use_red_hat_jboss_developer_studio_or_eclipse_to_run_the_quickstarts
:useEclipseDeployJavaClientDocUrl: {guidesBaseUrl}USE_JBDS.adoc#deploy_and_undeploy_a_quickstart_containing_server_and_java_client_projects
:useEclipseDeployEARDocUrl: {guidesBaseUrl}USE_JBDS.adoc#deploy_and_undeploy_a_quickstart_ear_project
:useProductHomeDocUrl: {guidesBaseUrl}USE_OF_{jbossHomeName}.adoc#use_of_product_home_and_jboss_home_variables
:configureMavenDocUrl: {guidesBaseUrl}CONFIGURE_MAVEN_JBOSS_EAP.adoc#configure_maven_to_build_and_deploy_the_quickstarts
:addUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#create_users_required_by_the_quickstarts
:addApplicationUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#add_an_application_user
:addManagementUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#add_an_management_user
:startServerDocUrl: {guidesBaseUrl}START_JBOSS_EAP.adoc#start_the_jboss_eap_server
:configurePostgresDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#configure_the_postgresql_database_for_use_with_the_quickstarts
:configurePostgresDownloadDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#download_and_install_postgresql
:configurePostgresCreateUserDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#create_a_database_user
:configurePostgresAddModuleDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#add_the_postgres_module_to_the_jboss_eap_server
:configurePostgresDriverDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#configure_the_postgresql_driver_in_the_jboss_eap_server
:configureBytemanDownloadDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#download_and_configure_byteman
:configureBytemanDisableDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#disable_the_byteman_script
:configureBytemanClearDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#clear_the_transaction_object_store
:configureBytemanQuickstartDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#configure_byteman_for_use_with_the_quickstarts
:configureBytemanHaltDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#use_byteman_to_halt_the_application[
:configureBytemanQuickstartsDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#configure_byteman_for_use_with_the_quickstarts

= micro-profile-jwt: MicroProfile JWT QuickStart
:author: Darran Lofthouse
:level: Intermediate
:technologies: JWT, Security, MicroProfile
:standalone-server-type: microprofile
:archiveType: war
:archiveName: microprofile-jwt.war
:openshift: true

[abstract]
The `microprofile-jwt` quickstart demonstrates the use of the MicroProfile JWT specification in {productName}.

== What is it?

The `microprofile-jwt` quickstart demonstrates the use of the MicroProfile JWT
specification in {productName}.  Within the quickstart the following topics will be covered: -

 * Creation of a simple Rest deployment as the base of the quickstart.
 * Initial calls to verify the endpoint is accessible.
 * Creation of public and private keys to enable generation and validation of JWT tokens.
 * Creation of a simple utility to generate JWT tokens.
 * Activation of `MP-JWT` authentication for the deployment.
 * Calling the rest endpoint with the generated JWT token.
 * Enabling authorization based on claims contained within the JWT token.
 * Injection of claims from the JWT token.

// Link to the quickstart source
:leveloffset: +1

ifndef::ProductRelease,EAPXPRelease[]
link:https://github.com/wildfly/quickstart/tree/{WildFlyQuickStartRepoTag}/{artifactId}[Browse the source]
endif::[]

:leveloffset!:

[[considerations_for_use_in_a_production_environment]]
== Considerations for Use in a Production Environment

To make it possible to execute this quickstart out of the box the public and private key are included in the
quickstart, as both keys are published publicly they should never be used in a production environment.

Although this quickstart demonstrates the functionality using a token generation utility, within a production
environment it would be more appropriate to make use of an identity provider to issue the tokens.

:leveloffset: +1

[[system_requirements]]
= System Requirements
//******************************************************************************
// Include this template to describe the standard system requirements for
// running the quickstarts.
//
// The Forge quickstarts define a `forge-from-scratch` attribute because they
// run entirely in CodeReady Studio and have different requirements .
//******************************************************************************

The application this project produces is designed to be run on {productNameFull} {productVersion} or later.

All you need to build this project is {buildRequirements}. See link:{configureMavenDocUrl}[Configure Maven to Build and Deploy the Quickstarts] to make sure you are configured correctly for testing the quickstarts.

:leveloffset!:
:leveloffset: +1

[[start_the_eap_standalone_server]]
= Start the {productName} Standalone Server
//******************************************************************************
// Include this template if your quickstart requires a normal start of a single
// standalone server.
//
// You must define the `standalone-server-type`. Supported values are:
//    default
//    full
//    full-ha
//    ha
//    custom
//
// * For mobile applications, you can define the `mobileApp` variable in the
//   `README.adoc` file to add `-b 0.0.0.0` to the command line. This allows
//    external clients, such as phones, tablets, and desktops, to connect
//    to the application through through your local network
//    ::mobileApp: {artifactId}-service
//
//******************************************************************************

//******************************************************************************
// This template sets attributes for the different standalone server profiles.
//
// You must define the `standalone-server-type`. Supported values are:
//    default
//    full
//    full-ha
//    ha
//    microprofile
//    custom
//******************************************************************************

// Standalone server with the default profile.
ifeval::["{standalone-server-type}"=="default"]
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::[]

// Standalone server with the full profile.
ifeval::["{standalone-server-type}"=="full"]
:serverProfile: full profile
:configFileName: standalone/configuration/standalone-full.xml
:serverArguments:  -c standalone-full.xml
endif::[]

// Standalone server with the full HA profile.
ifeval::["{standalone-server-type}"=="full-ha"]
:serverProfile: full HA profile
:configFileName: standalone/configuration/standalone-full-ha.xml
:serverArguments:  -c standalone-full-ha.xml
endif::[]

// Start the standalone server with the HA profile.
ifeval::["{standalone-server-type}"=="ha"]
:serverProfile: HA profile
:configFileName: standalone/configuration/standalone-ha.xml
:serverArguments:  -c standalone-ha.xml
endif::[]

// Start the standalone server with the Eclipse MicroProfile profile.
ifeval::["{standalone-server-type}"=="microprofile"]
:serverProfile: MicroProfile profile
:configFileName: standalone/configuration/standalone-microprofile.xml
:serverArguments:  -c standalone-microprofile.xml
endif::[]

// Standalone server with the custom profile.
// NOTE: This profile requires that you define the `serverArguments` variable
// within the quickstart README.adoc file. For example:
//  :serverArguments: --server-config=../../docs/examples/configs/standalone-xts.xml
ifeval::["{standalone-server-type}"=="custom"]
:serverProfile: custom profile
endif::[]

// If there is no match, use the default profile.
ifndef::serverProfile[]
:standalone-server-type:  default
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::serverProfile[]

. Open a terminal and navigate to the root of the {productName} directory.
. Start the {productName} server with the {serverProfile} by typing the following command.
+
ifdef::uses-jaeger[]
[source,subs="+quotes,attributes+",options="nowrap"]
----
$ __JAEGER_REPORTER_LOG_SPANS=true JAEGER_SAMPLER_TYPE=const JAEGER_SAMPLER_PARAM=1__ __{jbossHomeName}__/bin/standalone.sh {serverArguments}
----
endif::[]
ifndef::uses-jaeger[]
[source,subs="+quotes,attributes+",options="nowrap"]
----
$ __{jbossHomeName}__/bin/standalone.sh {serverArguments}
----
endif::[]
+
NOTE: For Windows, use the `__{jbossHomeName}__\bin\standalone.bat` script.

ifdef::mobileApp[]
+
Adding `-b 0.0.0.0` to the above command allows external clients, such as phones, tablets, and desktops, to connect through your local network. For example:
+
[source,subs="+quotes,attributes+",options="nowrap"]
----
$ __{jbossHomeName}__/bin/standalone.sh {serverArguments} -b 0.0.0.0
----
endif::[]

:leveloffset!:

// Build and Deploy the Quickstart
:leveloffset: +1

[[build_and_deploy_the_quickstart]]
= Build and Deploy the Quickstart
//******************************************************************************
// Include this template if your quickstart does a normal deployment of a archive.
//
// * Define the `archiveType` variable in the quickstart README file.
//   Supported values:
//    :archiveType: ear
//    :archiveType: war
//    :archiveType: jar
//
// * To override the archive name, which defaults to the {artifactId),
//   define the `archiveName` variable, for example:
//    :archiveName: {artifactId}-service
//
// * To override the archive output directory,
//   define the `archiveDir` variable, for example:
//    :archiveDir: ear/target
//
// * To override the Maven command, define the `mavenCommand` variable,
//   for example:
//    :mavenCommand: clean install wildfly:deploy
//******************************************************************************

// The archive name defaults to the artifactId if not overridden
ifndef::archiveName[]
:archiveName: {artifactId}
endif::archiveName[]

// The archive type defaults to war if not overridden
ifndef::archiveType[]
:archiveType: war
endif::archiveType[]

// Define the archive file name as the concatenation of "archiveName" + "." + "archiveType+
:archiveFileName: {archiveName}.{archiveType}

// If they have not defined the target archive directory, make it the default for the archive type.
ifndef::archiveDir[]

ifeval::["{archiveType}"=="ear"]
:archiveDir: {artifactId}/ear/target
endif::[]

ifeval::["{archiveType}"=="war"]
:archiveDir: {artifactId}/target
endif::[]

ifeval::["{archiveType}"=="jar"]
:archiveDir: {artifactId}/target
endif::[]

endif::archiveDir[]

ifndef::mavenCommand[]
ifeval::["{archiveType}"=="ear"]
:mavenCommand: clean install
endif::[]

ifeval::["{archiveType}"=="war"]
:mavenCommand: clean package
endif::[]

ifeval::["{archiveType}"=="jar"]
:mavenCommand: clean install
endif::[]

endif::mavenCommand[]

. Make sure {productName} server is started.
. Open a terminal and navigate to the root directory of this quickstart.
ifdef::reactive-messaging[]
. Run this command to enable the MicroProfile Reactive Messaging functionality on the server
+
[source,subs="attributes+",options="nowrap"]
----
$ __{jbossHomeName}__/bin/jboss-cli.sh --connect --file=enable-reactive-messaging.cli
----
endif::reactive-messaging[]
. Type the following command to build the quickstart.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn {mavenCommand}
----

. Type the following command to deploy the quickstart.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn wildfly:deploy
----

This deploys the `{archiveDir}/{archiveFileName}` to the running instance of the server.

You should see a message in the server log indicating that the archive deployed successfully.

:leveloffset!:

== Using the application

An unauthenticated call can be made to one of the deployed endpoints using the following command: -

[source]
----
$ curl http://localhost:8080/microprofile-jwt/Sample/helloworld
Hello anonymous
----

Using the token generation utility contained within the quickstart a new JWT can be created using the following command: -

[source]
----
$ mvn exec:java -Dexec.mainClass=org.wildfly.quickstarts.mpjwt.TokenUtil -Dexec.classpathScope=test -Dexec.args="testUser 2017-09-15 Echoer Subscriber"

JWT Header - {"kid":"Test Key","typ":"jwt","alg":"RS256"}

JWT Claims - {"sub":"testUser","upn":"testUser","iss":"quickstart-jwt-issuer","aud":"jwt-audience","groups":["Echoer","Subscriber"],"birthdate":"2017-09-15","jti":"3b89e56f-b8fd-4d5f-a1ed-080b958873f9","iat":1579886816,"exp":1579901216}

Generated JWT Token
eyJraWQiOiJUZXN0IEtleSIsInR5cCI6Imp3dCIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiJ0ZXN0VXNlciIsInVwbiI6InRlc3RVc2VyIiwiaXNzIjoicXVpY2tzdGFydC1qd3QtaXNzdWVyIiwiYXVkIjoiand0LWF1ZGllbmNlIiwiZ3JvdXBzIjpbIkVjaG9lciIsIlN1YnNjcmliZXIiXSwiYmlydGhkYXRlIjoiMjAxNy0wOS0xNSIsImp0aSI6IjNiODllNTZmLWI4ZmQtNGQ1Zi1hMWVkLTA4MGI5NTg4NzNmOSIsImlhdCI6MTU3OTg4NjgxNiwiZXhwIjoxNTc5OTAxMjE2fQ.srUrA3YwWg4V42Kdf5aLQzLiBO9u7ZCJ_bbNBrgU1XFhRBVzpLq4TJheN4ZFvTKDKFHFm2pa1_a_J70EONK9y8mzKnwiIfV1LbugophBE1xp7iDsBeOwGT8IKQVLaoniGGhqny_MkiMmcWt4tRzrTlJ4TOlCGKv3mZ_RzOj6xdWb12RK7-MTZYlRdnPD8kAfRT7QaJnRbuy5vIpqdz8cVg1y2KILBtg_yJB8s2jrx0ZYgTLDUH6yLpcxk43cLszDCfmdaZAoZFjAS9xUdAuk5eo7TBqt376q0BbE5DS8bHlo3ejWcNEwyo1dPD_TlKDJtNgeae89gru5Z2NOmc2XPA
----

A call can now be made to the first endpoint using the generated JWT token within the request message: -

[source]
----
$ curl -H "Authorization: Bearer eyJ...XPA" http://localhost:8080/microprofile-jwt/Sample/helloworld
Hello testUser
----

The quickstart also contains an endpoint which requires the identity to be granted the `Subscriber` role, using a generated token this can be
called using the following command: -

[source]
----
$ curl -H "Authorization: Bearer ey..XPA" http://localhost:8080/microprofile-jwt/Sample/subscription
hello + testUser, hasJWT: true
----

If a token is now generated and use without the `Subscriber` group access to this endpoint should be rejected.

[source]
----
$ mvn exec:java -Dexec.mainClass=org.wildfly.quickstarts.mpjwt.TokenUtil -Dexec.classpathScope=test -Dexec.args="testUser 2017-09-15 Echoer"

JWT Header - {"kid":"Test Key","typ":"jwt","alg":"RS256"}

JWT Claims - {"sub":"testUser","upn":"testUser","iss":"quickstart-jwt-issuer","aud":"jwt-audience","groups":["Echoer"],"birthdate":"2017-09-15","jti":"4346874f-eb48-4d84-ab51-c6efd1cd22d5","iat":1580136970,"exp":1580151370}

Generated JWT Token
eyJraWQiOiJUZXN0IEtleSIsInR5cCI6Imp3dCIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiJ0ZXN0VXNlciIsInVwbiI6InRlc3RVc2VyIiwiaXNzIjoicXVpY2tzdGFydC1qd3QtaXNzdWVyIiwiYXVkIjoiand0LWF1ZGllbmNlIiwiZ3JvdXBzIjpbIkVjaG9lciJdLCJiaXJ0aGRhdGUiOiIyMDE3LTA5LTE1IiwianRpIjoiNDM0Njg3NGYtZWI0OC00ZDg0LWFiNTEtYzZlZmQxY2QyMmQ1IiwiaWF0IjoxNTgwMTM2OTcwLCJleHAiOjE1ODAxNTEzNzB9.NjWlGGi5iB2PW-g_fs74EgwiyOrgRSsHDym5PS7H3o6T3aEb3ZnMmx7W9uhT_pXvpAL_fboXxy7WMQHukGb_ywtxAmTlA7ecrsia-O9EYV2Gr1ZhlQ9kYVERwZdo5lFqphMvERJ1tClTR3Jk37tpu54HVgFquhUEXlEcldOSeRbYHF9fkiVD6_UPR9bfphhCdwzIbeDVnBJ3FuRl_ZuSxWCoWaRSLPGjuR3JzMlUWkRV8RXhRLTkFRgNowOx_uFFK6q7_aOVqQaHixRqT4ULcO9WiA7f6Up0NMscvq-aT3VFw64qEmn2S8pfX7PpSuAB71Z7w0dwhf4qx3iYklfAPw

$ curl -H "Authorization: Bearer ey..APw" http://localhost:8080/microprofile-jwt/Sample/subscription
Access forbidden: role not allowed
----

The quickstart also contains an endpoint that makes use of the `birthdate` claim to calculate how long until the callers birthday, this can be called using a token which contains the `Subscriber` group.

[source]
----
$ curl -H "Authorization: Bearer ey..XPA" http://localhost:8080/microprofile-jwt/Sample/birthday
7 months and 19 days until your next birthday.
----

// Server Distribution Testing
:leveloffset: +1

[[run_the_integration_tests_with_server_distribution]]
= Run the Integration Tests
ifndef::integrationTestsDirectory[:integrationTestsDirectory: src/test/]
ifndef::extraStandardDistTestParams[:extraStandardDistTestParams: ]

This quickstart includes integration tests, which are located under the `{integrationTestsDirectory}` directory. The integration tests verify that the quickstart runs correctly when deployed on the server.

Follow these steps to run the integration tests.

. Make sure {productName} server is started.
. Make sure the quickstart is deployed.
. Type the following command to run the `verify` goal with the `integration-testing` profile activated.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn verify -Pintegration-testing {extraStandardDistTestParams}
----

:leveloffset!:
// Undeploy the Quickstart
:leveloffset: +1

[[undeploy_the_quickstart]]
= Undeploy the Quickstart

//*******************************************************************************
// Include this template if your quickstart does a normal undeployment of an archive.
//*******************************************************************************
When you are finished testing the quickstart, follow these steps to undeploy the archive.

. Make sure {productName} server is started.
. Open a terminal and navigate to the root directory of this quickstart.
. Type this command to undeploy the archive:
+
[source,options="nowrap"]
----
$ mvn wildfly:undeploy
----

:leveloffset!:

== Starting from Scratch

In this section we will go through the steps to create a new Jakarta REST deployment from scratch and incrementally
add support for MicroProfile JWT including token generation, activation of authorization and the injection
of claims.

=== Project Generation

This quickstart will be making use of Jakarta REST endpoints secured using MicroProfile JWT so the first step
is to generate a new `webapp` project: -

[source,options="nowrap"]
----
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=org.apache.maven.archetypes \
    -DarchetypeArtifactId=maven-archetype-webapp \
    -DgroupId=org.wildfly.quickstarts -DartifactId=microprofile-jwt \
    -Dversion=1.0.0.Alpha1-SNAPSHOT
cd microprofile-jwt
----

The changes required on the project can be performed using a text editor, however you may prefer to import the
project into your favourite IDE.

==== pom.xml Updates

Next the project's `pom.xml` should be updated so the dependencies required by this quickstart are
available and so we have a plug-in installed which can deploy the quickstart directly to {productName}.

Add the following properties to the `pom.xml`.

[source,options="nowrap",subs="attributes+"]
----
<version.com.nimbusds.jose.jwt>{versionComNimbusdsJoseJwt}</version.com.nimbusds.jose.jwt>
<version.glassfish.json>{versionGlassfishJson}</version.glassfish.json>
<version.bom.expansion>{versionExpansionBom}</version.bom.expansion>
<version.bom.ee>{versionServerBom}</version.bom.ee>
----

Also the project can be updated to use Java 17 as the minimum.

[source,options="nowrap"]
----
<maven.compiler.release>17</maven.compiler.release>
----

Before the dependencies are defined add the following boms.

[source,options="nowrap"]
----
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.wildfly.bom</groupId>
      <artifactId>wildfly-ee-with-tools</artifactId>
      <version>${version.bom.ee}</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
    <dependency>
      <groupId>org.wildfly.bom</groupId>
      <artifactId>wildfly-expansion</artifactId>
      <version>${version.bom.expansion}</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
----

By using BOMs the majority of dependencies used within this quickstart align with the version uses by the application server.

The following dependencies can now be added to the project.

[source,options="nowrap"]
----
<dependency>
  <groupId>jakarta.annotation</groupId>
  <artifactId>jakarta.annotation-api</artifactId>
  <scope>provided</scope>
</dependency>
<dependency>
  <groupId>jakarta.enterprise</groupId>
  <artifactId>jakarta.enterprise.cdi-api</artifactId>
  <scope>provided</scope>
</dependency>
<dependency>
  <groupId>jakarta.ws.rs</groupId>
  <artifactId>jakarta.ws.rs-api</artifactId>
  <scope>provided</scope>
</dependency>
<dependency>
  <groupId>org.eclipse.microprofile.jwt</groupId>
  <artifactId>microprofile-jwt-auth-api</artifactId>
  <scope>provided</scope>
</dependency>
----

Also add the following test scoped dependencies.

[source,options="nowrap"]
----
<dependency>
  <groupId>com.nimbusds</groupId>
  <artifactId>nimbus-jose-jwt</artifactId>
  <version>${version.com.nimbusds.jose.jwt}</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>jakarta.json</groupId>
  <artifactId>jakarta.json-api</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.glassfish</groupId>
  <artifactId>jakarta.json</artifactId>
  <version>${version.glassfish.json}</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.eclipse.parsson</groupId>
  <artifactId>parsson</artifactId>
  <scope>test</scope>
</dependency>
----

Within the `<build></build>` section of the project add the following plug-in definition.

[source,options="nowrap"]
----
<plugins>
  <plugin>
    <groupId>org.wildfly.plugins</groupId>
    <artifactId>wildfly-maven-plugin</artifactId>
  </plugin>
</plugins>
----

Once the project has been developed this plug-in will handle the deployment to the application server.

// Setup required repositories
:leveloffset: +1

Setup the required Maven repositories (if you don't have them set up in Maven global settings):

[source,xml]
----
<repositories>
    <repository>
        <id>jboss-public-maven-repository</id>
        <name>JBoss Public Maven Repository</name>
        <url>https://repository.jboss.org/nexus/content/groups/public</url>
        <layout>default</layout>
        <releases>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </releases>
        <snapshots>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </snapshots>
    </repository>
    <repository>
        <id>redhat-ga-maven-repository</id>
        <name>Red Hat GA Maven Repository</name>
        <url>https://maven.repository.redhat.com/ga/</url>
        <layout>default</layout>
        <releases>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </releases>
        <snapshots>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </snapshots>
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
        <id>jboss-public-maven-repository</id>
        <name>JBoss Public Maven Repository</name>
        <url>https://repository.jboss.org/nexus/content/groups/public</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>redhat-ga-maven-repository</id>
        <name>Red Hat GA Maven Repository</name>
        <url>https://maven.repository.redhat.com/ga/</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
</pluginRepositories>
----

:leveloffset!:

==== Jakarta REST Conversion

The generated project is a standard web application so the next step will be to delete the files not
required by this quickstart and add the Jakarta REST application and a `helloWorld` endpoint.

Under `src/main/webapp` delete the generated `index.jsp`.

Within the directory `src/main/webapp/WEB-INF` add an empty `beans.xml` file, this will act as a trigger
to enable CDI for the deployment.

Under `src/main` create a new `java` directory to hold the Java class to be added to the project.

Add the following class in the `org.wildfly.quickstarts.mpjwt` package, this will be the main trigger to
process the deployment as a Jakarta REST deployment.

[source,java]
----
package org.wildfly.quickstarts.mpjwt;

import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

import org.eclipse.microprofile.auth.LoginConfig;

@ApplicationPath("/")
@LoginConfig(authMethod="MP-JWT", realmName="MP JWT Realm")
public class App extends Application {}
----

Also within the `org.wildfly.quickstarts.mpjwt` package add the following endpoint.

[source,java]
----
package org.wildfly.quickstarts.mpjwt;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;


@Path("/Sample")
public class SampleEndPoint {

    @GET
    @Path("/helloworld")
    public String helloworld() {
        return "Hello World";
    }

}
----

At this stage the project contains a simple Jakarta REST endpoint we can deploy to the server and invoke to verify
everything is working as expected before moving on to enable JWT based authentication and authorization.

First build the example and deploy it to the previously started application server.

. Compile the application code and deploy it to {productName}
[source]
----
$ mvn clean package wildfly:deploy
----

In the output of the application server's console check the deployment deployed successfully.

[source]
----
15:48:22,159 INFO  [org.jboss.resteasy.resteasy_jaxrs.i18n] (ServerService Thread Pool -- 78) RESTEASY002225: Deploying jakarta.ws.rs.core.Application: class org.wildfly.quickstarts.mpjwt.App$Proxy$_$$_WeldClientProxy
15:48:22,193 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 78) WFLYUT0021: Registered web context: '/microprofile-jwt' for server 'default-server'
15:48:22,239 INFO  [org.jboss.as.server] (management-handler-thread - 1) WFLYSRV0010: Deployed "microprofile-jwt.war" (runtime-name : "microprofile-jwt.war")
----

The endpoint can now be called using the following command: -

[source]
----
$ curl http://localhost:8080/microprofile-jwt/Sample/helloworld
Hello World
----

Alternative HTTP clients can be used however later on we will be adding custom headers to the HTTP request which can be acomplished directly with the `curl` command.

=== Report Authenticated Identity

The first update to make to the project is to modify the `/helloworld` to report the name of the presently authenticated identity.

Make the following changes to the previously created `org.wildfly.quickstarts.mpjwt.SampleEndPoint` class.

Add the following `import` statements to the class.

[source,java]
----
import java.security.Principal;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.SecurityContext;
----

Then replace the existing `helloWorld()` method with the following: -

[source,java]
----
@GET
@Path("/helloworld")
public String helloworld(@Context SecurityContext securityContext) {
    Principal principal = securityContext.getUserPrincipal();
    String caller = principal == null ? "anonymous" : principal.getName();

    return "Hello " + caller;
}
----

As before, deploy and call the endpoint.

[source]
----
$ mvn package wildfly:deploy

$ curl http://localhost:8080/microprofile-jwt/Sample/helloworld
Hello anonymous
----

=== Public / Private Key

Now that we have a deployable project our next step on the project will be to enable `MP-JWT` authentication, however before we can do this a couple of steps are
required the first being the generation of a public / private key pair for token signing and verification.

For MicroProfile JWT we only require the keys, we do not require an X509Certificate so we can use openssl to generate the raw keys.

[source,options="nowrap"]
----
$ openssl genpkey -algorithm RSA -out private.pem -pkeyopt rsa_keygen_bits:2048
----

From this we can then export the public key that will be included in the deployment.

[source,options="nowrap"]
----
$ mkdir -p src/main/resources/META-INF
$ openssl rsa -in private.pem -pubout -out src/main/resources/META-INF/public.pem
----

The commands used here offer no protection of the generated keys, in a real world environment any private keys that can be used for token generation should be handled securely.

=== Token Generator

The next step is to add a utility to the project which can be used to generate JWT tokens for use with this example.

First create a directory to hold the test code.

[source,options="nowrap"]
----
$ mkdir -p src/test/java
----

Under `src/test/java` add the following utility class to the `org.wildfly.quickstarts.mpjwt` package.

[source,java]
----
package org.wildfly.quickstarts.mpjwt;

import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.UUID;

import jakarta.json.Json;
import jakarta.json.JsonArrayBuilder;
import jakarta.json.JsonObjectBuilder;

import com.nimbusds.jose.JOSEObjectType;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSObject;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSASSASigner;

public class TokenUtil {

    private static PrivateKey loadPrivateKey(final String fileName) throws Exception {
        try (InputStream is = new FileInputStream(fileName)) {
            byte[] contents = new byte[4096];
            int length = is.read(contents);
            String rawKey = new String(contents, 0, length, StandardCharsets.UTF_8)
                    .replaceAll("-----BEGIN (.*)-----", "")
                    .replaceAll("-----END (.*)----", "")
                    .replaceAll("\r\n", "").replaceAll("\n", "").trim();

            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(rawKey));
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");

            return keyFactory.generatePrivate(keySpec);
        }
    }

    public static String generateJWT(final String principal, final String birthdate, final String...groups) throws Exception {
    	PrivateKey privateKey = loadPrivateKey("private.pem");

        JWSSigner signer = new RSASSASigner(privateKey);
        JsonArrayBuilder groupsBuilder = Json.createArrayBuilder();
        for (String group : groups) { groupsBuilder.add(group); }

        long currentTime = System.currentTimeMillis() / 1000;
        JsonObjectBuilder claimsBuilder = Json.createObjectBuilder()
                .add("sub", principal)
                .add("upn", principal)
                .add("iss", "quickstart-jwt-issuer")
                .add("aud", "jwt-audience")
                .add("groups", groupsBuilder.build())
                .add("birthdate", birthdate)
                .add("jti", UUID.randomUUID().toString())
                .add("iat", currentTime)
                .add("exp", currentTime + 14400);

        JWSObject jwsObject = new JWSObject(new JWSHeader.Builder(JWSAlgorithm.RS256)
                .type(new JOSEObjectType("jwt"))
                .keyID("Test Key").build(),
                new Payload(claimsBuilder.build().toString()));

        jwsObject.sign(signer);

        return jwsObject.serialize();
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 2) throw new IllegalArgumentException("Usage TokenUtil {principal} {birthdate} {groups}");
        String principal = args[0];
        String birthdate = args[1];
        String[] groups = new String[args.length - 2];
        System.arraycopy(args, 2, groups, 0, groups.length);

        String token = generateJWT(principal, birthdate, groups);
        String[] parts = token.split("\\.");
        System.out.println(String.format("\nJWT Header - %s", new String(Base64.getDecoder().decode(parts[0]), StandardCharsets.UTF_8)));
        System.out.println(String.format("\nJWT Claims - %s", new String(Base64.getDecoder().decode(parts[1]), StandardCharsets.UTF_8)));
        System.out.println(String.format("\nGenerated JWT Token \n%s\n", token));
    }
}
----

After adding the class the project will need to be compiled again and can then be executed using Maven.

[source]
----
$ mvn package
...
$ mvn exec:java -Dexec.mainClass=org.wildfly.quickstarts.mpjwt.TokenUtil -Dexec.classpathScope=test -Dexec.args="testUser 2017-09-15 Echoer Subscriber"

JWT Header - {"kid":"Test Key","typ":"jwt","alg":"RS256"}

JWT Claims - {"sub":"testUser","upn":"testUser","iss":"quickstart-jwt-issuer","aud":"jwt-audience","groups":["Echoer","Subscriber"],"birthdate":"2017-09-15","jti":"3b89e56f-b8fd-4d5f-a1ed-080b958873f9","iat":1579886816,"exp":1579901216}

Generated JWT Token
eyJraWQiOiJUZXN0IEtleSIsInR5cCI6Imp3dCIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiJ0ZXN0VXNlciIsInVwbiI6InRlc3RVc2VyIiwiaXNzIjoicXVpY2tzdGFydC1qd3QtaXNzdWVyIiwiYXVkIjoiand0LWF1ZGllbmNlIiwiZ3JvdXBzIjpbIkVjaG9lciIsIlN1YnNjcmliZXIiXSwiYmlydGhkYXRlIjoiMjAxNy0wOS0xNSIsImp0aSI6IjNiODllNTZmLWI4ZmQtNGQ1Zi1hMWVkLTA4MGI5NTg4NzNmOSIsImlhdCI6MTU3OTg4NjgxNiwiZXhwIjoxNTc5OTAxMjE2fQ.srUrA3YwWg4V42Kdf5aLQzLiBO9u7ZCJ_bbNBrgU1XFhRBVzpLq4TJheN4ZFvTKDKFHFm2pa1_a_J70EONK9y8mzKnwiIfV1LbugophBE1xp7iDsBeOwGT8IKQVLaoniGGhqny_MkiMmcWt4tRzrTlJ4TOlCGKv3mZ_RzOj6xdWb12RK7-MTZYlRdnPD8kAfRT7QaJnRbuy5vIpqdz8cVg1y2KILBtg_yJB8s2jrx0ZYgTLDUH6yLpcxk43cLszDCfmdaZAoZFjAS9xUdAuk5eo7TBqt376q0BbE5DS8bHlo3ejWcNEwyo1dPD_TlKDJtNgeae89gru5Z2NOmc2XPA
----

We now have everything we need to activate `MP-JWT` authentication on the deployment and start accepting JWT tokens within the HTTP requests.

=== Activating MicroProfile JWT

At this stage we have a basic Jakarta REST deployment, a pair of keys for the generation of and validation of JWT tokens and a utility to generate JWT tokens.
Our next step is to activate MicroProfile JWT authentication for the deployment and we can then make use of some of the advanced features such as role
based access control using the groups from within the token and access to individual claims within the token.

The configuration for JWT validation can be contained within a MicroProfile Config properties file, under `src/main/resources/META-INF`
add a `microprofile-config.properties` with the following content.

[source]
----
mp.jwt.verify.publickey.location=META-INF/public.pem
mp.jwt.verify.issuer=quickstart-jwt-issuer
----

As before, deploy and call the endpoint.

[source]
----
$ mvn package wildfly:deploy

$ curl http://localhost:8080/microprofile-jwt/Sample/helloworld
Hello anonymous
----

A new token can now be generated using the TokenUtility created previously and the token passed in as we call the endpoint.

[source]
----
$ curl -H "Authorization: Bearer eyJ...59g" http://localhost:8080/microprofile-jwt/Sample/helloworld
Hello testUser
----

At this point our first endpoint now supports optional authentication making use of a JWT token.

=== Authorization

Now that authentication has been activated we can add another endpoint that requires the caller to have been granted the
‘Subscribers’ role which will be based on the groups in the incoming JWT token.

The following imports should be added to the “SampleEndPoint” class: -

[source,java]
----
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;

import org.eclipse.microprofile.jwt.JsonWebToken;
----

And then the following new endpoint can be added: -

[source,java]
----
@Inject
JsonWebToken jwt;

@GET()
@Path("/subscription")
@RolesAllowed({"Subscriber"})
public String helloRolesAllowed(@Context SecurityContext ctx) {
    Principal caller =  ctx.getUserPrincipal();
    String name = caller == null ? "anonymous" : caller.getName();
    boolean hasJWT = jwt.getClaimNames() != null;
    String helloReply = String.format("hello + %s, hasJWT: %s", name, hasJWT);
    return helloReply;
}
----


Within WildFly the Jakarta REST deployment is handled by RESTEasy so under `src/main/webapp/WEB-INF` add the following to the web.xml to enable RESTEasy authorization checks.

[source,xml]
----
<context-param>
    <param-name>resteasy.role.based.security</param-name>
    <param-value>true</param-value>
</context-param>

<security-role>
    <role-name>Subscriber</role-name>
</security-role>
----

As before, build and deploy the example.

[source]
----
$ mvn package wildfly:deploy
----

Using a recently generated token the new endpoint can be called.

[source]
----
$ curl -H "Authorization: Bearer ey..59g" http://localhost:8080/microprofile-jwt/Sample/subscription
hello + testUser, hasJWT: true
----

If a token is now generated without including the “Subscriber” group access should be denied to the endpoint.

[source]
----
$ curl -H "Authorization: Bearer ey..Pw" http://localhost:8080/microprofile-jwt/Sample/subscription
Access forbidden: role not allowed
----

=== Claims

A final feature that will be explored within this Quickstart is accessing the claims contained within the JWT.

The JWTToken in the previous example can be used to inspect the claims, however it is also possible to inject the specific claim.

The following imports should be added to the “SampleEndPoint” class: -

[source,java]
----
import java.time.LocalDate;
import java.time.Period;
import java.util.Optional;

import org.eclipse.microprofile.jwt.Claims;
import org.eclipse.microprofile.jwt.Claim;
----

And then the following new endpoint can be added: -

[source,java]
----
@Inject
@Claim(standard = Claims.birthdate)
Optional<String> birthdate;

@GET()
@Path("/birthday")
@RolesAllowed({ "Subscriber" })
public String birthday() {
    if (birthdate.isPresent()) {
        LocalDate birthdate = LocalDate.parse(this.birthdate.get().toString());
        LocalDate today = LocalDate.now();
        LocalDate next = birthdate.withYear(today.getYear());
        if (today.equals(next)) {
            return "Happy Birthday";
        }
        if (next.isBefore(today)) {
            next = next.withYear(next.getYear() + 1);
        }
        Period wait = today.until(next);
        return String.format("%d months and %d days until your next birthday.", wait.getMonths(), wait.getDays());
    }
    return "Sorry, we don't know your birthdate.";
}
----

As with the previous endpoint the caller is required to have been granted the `Subscriber` role, if a `birthdate` claim is present within
the JWT token this endpoint will calculate how many days until the next birthday and wish you happy birthday it if is today.

As before, build and deploy the example.

[source]
----
$ mvn package wildfly:deploy
----

Using a recently generated token the new endpoint can be called.

[source]
----
$ curl -H "Authorization: Bearer ey..59g" http://localhost:8080/microprofile-jwt/Sample/birthday
7 months and 19 days until your next birthday.
----

// Bootable JAR
:leveloffset: +1

[[build_and_run_the_quickstart_with_bootable_jar]]
= Building and Running the quickstart application in a bootable JAR

//******************************************************************************
// This template sets attributes for the different standalone server profiles.
//
// You must define the `standalone-server-type`. Supported values are:
//    default
//    full
//    full-ha
//    ha
//    microprofile
//    custom
//******************************************************************************

// Standalone server with the default profile.
ifeval::["{standalone-server-type}"=="default"]
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::[]

// Standalone server with the full profile.
ifeval::["{standalone-server-type}"=="full"]
:serverProfile: full profile
:configFileName: standalone/configuration/standalone-full.xml
:serverArguments:  -c standalone-full.xml
endif::[]

// Standalone server with the full HA profile.
ifeval::["{standalone-server-type}"=="full-ha"]
:serverProfile: full HA profile
:configFileName: standalone/configuration/standalone-full-ha.xml
:serverArguments:  -c standalone-full-ha.xml
endif::[]

// Start the standalone server with the HA profile.
ifeval::["{standalone-server-type}"=="ha"]
:serverProfile: HA profile
:configFileName: standalone/configuration/standalone-ha.xml
:serverArguments:  -c standalone-ha.xml
endif::[]

// Start the standalone server with the Eclipse MicroProfile profile.
ifeval::["{standalone-server-type}"=="microprofile"]
:serverProfile: MicroProfile profile
:configFileName: standalone/configuration/standalone-microprofile.xml
:serverArguments:  -c standalone-microprofile.xml
endif::[]

// Standalone server with the custom profile.
// NOTE: This profile requires that you define the `serverArguments` variable
// within the quickstart README.adoc file. For example:
//  :serverArguments: --server-config=../../docs/examples/configs/standalone-xts.xml
ifeval::["{standalone-server-type}"=="custom"]
:serverProfile: custom profile
endif::[]

// If there is no match, use the default profile.
ifndef::serverProfile[]
:standalone-server-type:  default
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::serverProfile[]

ifndef::mavenServerProvisioningCommand[]
ifeval::["{archiveType}"=="ear"]
:mavenServerProvisioningCommand: clean install
endif::[]
ifeval::["{archiveType}"=="war"]
:mavenServerProvisioningCommand: clean package
endif::[]
ifeval::["{archiveType}"=="jar"]
:mavenServerProvisioningCommand: clean install
endif::[]
endif::mavenServerProvisioningCommand[]

You can use the WildFly Maven Plugin to build a {productName} bootable JAR to run this quickstart.

The quickstart `pom.xml` file contains a Maven profile named *bootable-jar*, which activates the bootable JAR packaging when provisioning {productName}, through the `<bootable-jar>true</bootable-jar>` configuration element:

[source,xml,subs="attributes+"]
----
      <profile>
          <id>bootable-jar</id>
          <activation>
              <activeByDefault>true</activeByDefault>
          </activation>
          <build>
              <plugins>
                  <plugin>
                      <groupId>org.wildfly.plugins</groupId>
                      <artifactId>wildfly-maven-plugin</artifactId>
                      <configuration>
                          <discover-provisioning-info>
                              <version>${version.server}</version>
                          </discover-provisioning-info>
                          <bootable-jar>true</bootable-jar>
                          <add-ons>...</add-ons>
                      </configuration>
                      <executions>
                          <execution>
                              <goals>
                                  <goal>package</goal>
                              </goals>
                          </execution>
                      </executions>
                  </plugin>
                  ...
              </plugins>
          </build>
      </profile>
----

The *bootable-jar* profile is activate by default, and when built the {productName} bootable jar file is named `{artifactId}-bootable.jar`, and may be found in the `target` directory.

.Procedure

. Ensure the bootable jar is built.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn {mavenServerProvisioningCommand}
----

. Start the {productName} bootable jar use the WildFly Maven Plugin `start-jar` goal.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn wildfly:start-jar
----
+
[NOTE]
====
You may also start the bootable jar without Maven, using the `java` command.
[source,subs="attributes+",options="nowrap"]
----
$ java -jar target/{artifactId}-bootable.jar
----
====

. Run the integration tests use the `verify` goal, with the `integration-testing` profile activated.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn verify -Pintegration-testing
----

. Shut down the {productName} bootable jar use the WildFly Maven Plugin `shutdown` goal.
+
[source,options="nowrap"]
----
$ mvn wildfly:shutdown
----


:leveloffset!:

// OpenShift
:leveloffset: +1

:cloud-platform: OpenShift
:openshift: true
ifndef::helm-app-name[]
:helm-app-name: {artifactId}
endif::helm-app-name[]

[[build_and_run_the_quickstart_on_openshift]]
= Building and running the quickstart application with OpenShift
// The openshift profile
:leveloffset: +1

[[build-the-quickstart-for-openshift]]
== Build the {productName} Source-to-Image (S2I) Quickstart to {cloud-platform} with Helm Charts

On OpenShift, the S2I build with Apache Maven uses an `openshift` Maven profile to provision a {productName} server, deploy and run the quickstart in OpenShift environment.

ifndef::ProductRelease,EAPXPRelease[]
The server provisioning functionality is provided by the WildFly Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
endif::[]
ifdef::ProductRelease,EAPXPRelease[]
The server provisioning functionality is provided by the EAP Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
endif::[]

ifndef::ProductRelease,EAPXPRelease[]

[source,xml,subs="attributes+"]
----
        <profile>
            <id>openshift</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.wildfly.plugins</groupId>
                        <artifactId>wildfly-maven-plugin</artifactId>
                        <configuration>
                            <discover-provisioning-info>
                                <version>${version.server}</version>
                                <context>cloud</context>
                            </discover-provisioning-info>
                            <add-ons>...</add-ons>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>package</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    ...
                </plugins>
            </build>
        </profile>
----
You may note that unlike the `provisioned-server` profile it uses the cloud context which enables a configuration tuned for {cloud-platform} environment.

The plugin uses https://github.com/wildfly/wildfly-glow[WildFly Glow] to discover the feature packs and layers required to run the application, and provisions a server containing those layers.

If you get an error or the server is missing some functionality which cannot be auto-discovered, you can download the https://github.com/wildfly/wildfly-glow/releases[WildFly Glow CLI] and run the following command to see more information about what add-ons are available:
[source,shell]
----
wildfly-glow show-add-ons
----
endif::ProductRelease,EAPXPRelease[]

ifdef::ProductRelease,EAPXPRelease[]
[source,xml,subs="attributes+"]
----
        <profile>
            <id>openshift</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.jboss.eap.plugins</groupId>
                        <artifactId>eap-maven-plugin</artifactId>
                        <configuration>
                            ...
                            <feature-packs>
                                <feature-pack>
                                    <location>org.jboss.eap:wildfly-ee-galleon-pack</location>
                                </feature-pack>
                                <feature-pack>
                                    <location>org.jboss.eap.cloud:eap-cloud-galleon-pack</location>
                                </feature-pack>
                            </feature-packs>
                            <layers>...</layers>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>package</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    ...
                </plugins>
            </build>
        </profile>
----
You may note that it uses the cloud feature pack which enables a configuration tuned for the {cloud-platform} environment.
endif::[]

:leveloffset: 1
// Getting Started with Helm
:leveloffset: +1

[[getting_started_with_helm]]
= Getting Started with {xpaasproduct-shortname} and Helm Charts

This section contains the basic instructions to build and deploy this quickstart to {xpaasproduct-shortname} or {xpaasproductOpenShiftOnline-shortname} using Helm Charts.

[[prerequisites_helm_openshift]]
== Prerequisites

ifndef::kubernetes[]
* You must be logged in OpenShift and have an `oc` client to connect to OpenShift
endif::[]
* https://helm.sh[Helm] must be installed to deploy the backend on {cloud-platform}.

Once you have installed Helm, you need to add the repository that provides Helm Charts for {productName}.

ifndef::ProductRelease,EAPXPRelease[]
[source,options="nowrap"]
----
$ helm repo add wildfly https://docs.wildfly.org/wildfly-charts/
"wildfly" has been added to your repositories
$ helm search repo wildfly
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
wildfly/wildfly         ...             ...            Build and Deploy WildFly applications on OpenShift
wildfly/wildfly-common  ...             ...            A library chart for WildFly-based applications
----
endif::[]
ifdef::ProductRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP {productVersion} applications
----
endif::[]
ifdef::EAPXPRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP XP {productVersion} applications
----
endif::[]

:leveloffset: 1

ifdef::helm-install-prerequisites-openshift[]
// Additional steps needed before deploying in Helm
[[deploy_helm_prerequisites]]
include::{helm-install-prerequisites-openshift}[leveloffset=+1]
endif::helm-install-prerequisites-openshift[]

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

ifndef::helmSetWildFlyArgumentPrefix[]
// For use with nested Helm charts
:helmSetWildFlyArgumentPrefix:
endif::[]
ifeval::[{useHelmChartDir} == true]
:helm_chart_values: charts
endif::[]
ifndef::useHelmChartDir[]
:helm_chart_values: -f charts/helm.yaml {helmChartName}
endif::[]
ifdef::kubernetes[]
:helm-set-build-enabled: --set {helmSetWildFlyArgumentPrefix}build.enabled=false
:helm-set-deploy-route-enabled: --set {helmSetWildFlyArgumentPrefix}deploy.route.enabled=false
:helm-set-image-name: --set {helmSetWildFlyArgumentPrefix}image.name="localhost:5000/{artifactId}"
:helm-extra-arguments: {helm-set-build-enabled} {helm-set-deploy-route-enabled} {helm-set-image-name}
:cloud-cli: kubectl
endif::[]
ifndef::kubernetes[]
:helm-extra-arguments:
:cloud-cli: oc
endif::[]
[[deploy_helm]]
== Deploy the {ProductShortName} Source-to-Image (S2I) Quickstart to {cloud-platform} with Helm Charts

ifndef::kubernetes[]
Log in to your OpenShift instance using the `oc login` command.
endif::[]
The backend will be built and deployed on {cloud-platform} with a Helm Chart for {productName}.


ifndef::kubernetes[]
Navigate to the root directory of this quickstart and run the following command:
endif::[]
ifdef::kubernetes[]
Navigate to the root directory of this quickstart and run the following commands:

[source,options="nowrap",subs="+attributes"]
----
mvn -Popenshift package wildfly:image
----
This will use the `openshift` Maven profile we saw earlier to build the application, and create a Docker image containing the {productName} server with the application deployed. The name of the image will be `{artifactId}`.

Next we need to tag the image and make it available to Kubernetes. You can push it to a registry like `quay.io`. In this case we tag as `localhost:5000/{artifactId}:latest` and push it to the internal registry in our Kubernetes instance:

[source,options="nowrap",subs="+attributes"]
----
# Tag the image
docker tag {artifactId} localhost:5000/{artifactId}:latest
# Push the image to the registry
docker push localhost:5000/{artifactId}:latest
----

In the below call to `helm install` which deploys our application to Kubernetes, we are passing in some extra arguments to tweak the Helm build:

* `{helm-set-build-enabled}` - This turns off the s2i build for the Helm chart since Kubernetes, unlike OpenShift, does not have s2i. Instead, we are providing the image to use.
* `{helm-set-deploy-route-enabled}` - This disables route creation normally performed by the Helm chart. On Kubernetes we will use port-forwards instead to access our application, since routes are an OpenShift specific concept and thus not available on Kubernetes.
* `{helm-set-image-name}` - This tells the Helm chart to use the image we built, tagged and pushed to Kubernetes' internal registry above.

endif::[]
[source,options="nowrap",subs="+attributes"]
----
$ helm install {helm-app-name} {helm_chart_values} --wait --timeout=10m0s {helm-extra-arguments}
NAME: {helm-app-name}
...
STATUS: deployed
REVISION: 1
----

This command will return once the application has successfully deployed. In case of a timeout, you can check the status of the application with the following command in another terminal:

[source,options="nowrap",subs="+attributes"]
----
{cloud-cli} get deployment {helm-app-name}
----

The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I on Java 17:


ifndef::requires-http-route[]
ifdef::useHelmChartDir[]
[source,yaml]
----
include::{docdir}/charts/Chart.yaml[]
----
endif::useHelmChartDir[]
ifndef::useHelmChartDir[]
[source,yaml]
----
build:
  uri: https://github.com/wildfly/quickstart.git
  ref: main
  contextDir: microprofile-jwt
deploy:
  replicas: 1
----
endif::useHelmChartDir[]
endif::requires-http-route[]

ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
build:
  uri: {githubRepoCodeUrl}
  ref: {WildFlyQuickStartRepoTag}
  contextDir: {artifactId}
deploy:
  replicas: 1
  route:
    tls:
      enabled: false
----
endif::requires-http-route[]

This will create a new deployment on {cloud-platform} and deploy the application.

If you want to see all the configuration elements to customize your deployment you can use the following command:
[source,options="nowrap",subs="+attributes"]
----
$ helm show readme {helmChartName}
----

ifdef::openshift[]
Get the URL of the route to the deployment.

[source,options="nowrap",subs="+attributes"]
----
$ oc get route {helm-app-name} -o jsonpath="{.spec.host}"
----
Access the application in your web browser using the displayed URL.
endif::[]
ifdef::kubernetes[]
To be able to connect to our application running in Kubernetes from outside, we need to set up a port-forward to the `{helm-app-name}` service created for us by the Helm chart.

This service will run on port `8080`, and we set up the port forward to also run on port `8080`:

[source,options="nowrap",subs="+attributes"]
----
kubectl port-forward service/{helm-app-name} 8080:8080
----
The server can now be accessed via `http://localhost:8080` from outside Kubernetes. Note that the command to create the port-forward will not return, so it is easiest to run this in a separate terminal.

endif::[]

ifdef::openshift+post-helm-install-actions-openshift[]
include::{post-helm-install-actions-openshift}[leveloffset=+1]
endif::openshift+post-helm-install-actions-openshift[]
ifdef::kubernetes+post-helm-install-actions-kubernetes[]
include::{post-helm-install-actions-kubernetes}[leveloffset=+1]
endif::kubernetes+post-helm-install-actions-kubernetes[]

:leveloffset: 1

// Testing on Openshift
:leveloffset: +1

[[run_the_integration_tests_with_openshift]]
= Run the Integration Tests with OpenShift
The integration tests included with this quickstart, which verify that the quickstart runs correctly, may also be run with the quickstart running on OpenShift.
[NOTE]
====
The integration tests expect a deployed application, so make sure you have deployed the quickstart on OpenShift before you begin.
====

ifdef::extra-testing-actions-openshift[]
include::{extra-testing-actions-openshift}[leveloffset=+1]
endif::extra-testing-actions-openshift[]

ifndef::extra-test-arguments-openshift[:extra-test-arguments-openshift:]

Run the integration tests using the following command to run the `verify` goal with the `integration-testing` profile activated and the proper URL:
ifndef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=https://$(oc get route {helm-app-name} --template='{{ .spec.host }}') {extra-test-arguments-openshift}
----
endif::requires-http-route[]
ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=http://$(oc get route {helm-app-name} --template='{{ .spec.host }}') {extra-test-arguments-openshift}
----
endif::requires-http-route[]

[NOTE]
====
The tests are using SSL to connect to the quickstart running on OpenShift. So you need the certificates to be trusted by the machine the tests are run from.
====

:leveloffset: 1

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

[[undeploy_helm]]
== Undeploy the {ProductShortName} Source-to-Image (S2I) Quickstart from {cloud-platform} with Helm Charts

[source,options="nowrap",subs="+attributes"]
----
$ helm uninstall {helm-app-name}
----
ifdef::kubernetes[]
To stop the port forward you created earlier use:
[source,options="nowrap",subs="+attributes"]
----
$ kubectl port-forward service/{helm-app-name} 8080:8080
----
endif::[]

:leveloffset: 1

// Unset the attribute
:!openshift:

:leveloffset!:
ifndef::ProductRelease,EAPXPRelease[]
// Kubernetes
:leveloffset: +1

:cloud-platform: Kubernetes
:kubernetes: true
ifndef::helm-app-name[]
:helm-app-name: {artifactId}
endif::helm-app-name[]

[[build_and_run_the_quickstart_on_kubernetes]]
= Building and running the quickstart application with Kubernetes
// The openshift profile
:leveloffset: +1

[[build-the-quickstart-for-kubernetes]]
== Build the {productName} Quickstart to Kubernetes with Helm Charts

For Kubernetes, the build with Apache Maven uses an `openshift` Maven profile to provision a {productName} server, suitable for running on Kubernetes.

ifndef::ProductRelease,EAPXPRelease[]
The server provisioning functionality is provided by the WildFly Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
endif::[]
ifdef::ProductRelease,EAPXPRelease[]
The server provisioning functionality is provided by the EAP Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
endif::[]

ifndef::ProductRelease,EAPXPRelease[]

[source,xml,subs="attributes+"]
----
        <profile>
            <id>openshift</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.wildfly.plugins</groupId>
                        <artifactId>wildfly-maven-plugin</artifactId>
                        <configuration>
                            <discover-provisioning-info>
                                <version>${version.server}</version>
                                <context>cloud</context>
                            </discover-provisioning-info>
                            <add-ons>...</add-ons>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>package</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    ...
                </plugins>
            </build>
        </profile>
----
You may note that unlike the `provisioned-server` profile it uses the cloud context which enables a configuration tuned for {cloud-platform} environment.

The plugin uses https://github.com/wildfly/wildfly-glow[WildFly Glow] to discover the feature packs and layers required to run the application, and provisions a server containing those layers.

If you get an error or the server is missing some functionality which cannot be auto-discovered, you can download the https://github.com/wildfly/wildfly-glow/releases[WildFly Glow CLI] and run the following command to see more information about what add-ons are available:
[source,shell]
----
wildfly-glow show-add-ons
----
endif::ProductRelease,EAPXPRelease[]

ifdef::ProductRelease,EAPXPRelease[]
[source,xml,subs="attributes+"]
----
        <profile>
            <id>openshift</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.jboss.eap.plugins</groupId>
                        <artifactId>eap-maven-plugin</artifactId>
                        <configuration>
                            ...
                            <feature-packs>
                                <feature-pack>
                                    <location>org.jboss.eap:wildfly-ee-galleon-pack</location>
                                </feature-pack>
                                <feature-pack>
                                    <location>org.jboss.eap.cloud:eap-cloud-galleon-pack</location>
                                </feature-pack>
                            </feature-packs>
                            <layers>...</layers>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>package</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    ...
                </plugins>
            </build>
        </profile>
----
You may note that it uses the cloud feature pack which enables a configuration tuned for the {cloud-platform} environment.
endif::[]

:leveloffset: 1
// Getting Started with Helm
:leveloffset: +1

[[getting_started_with_helm]]
= Getting Started with Kubernetes and Helm Charts

This section contains the basic instructions to build and deploy this quickstart to Kubernetes using Helm Charts.

== Install Kubernetes
In this example we are using https://github.com/kubernetes/minikube[Minikube] as our Kubernetes provider. See the https://minikube.sigs.k8s.io/docs/start/[Minikube Getting Started guide] for how to install it. After installing it, we start it with 4GB of memory.

[source,options="nowrap",subs="+attributes"]
----
minikube start --memory='4gb'
----
The above command should work if you have Docker installed on your machine. If, you are using https://podman-desktop.io[Podman] instead of Docker, you will also need to pass in `--driver=podman`, as covered in the https://minikube.sigs.k8s.io/docs/handbook/config/[Minikube documentation].

Once Minikube has started, we need to enable its https://minikube.sigs.k8s.io/docs/handbook/registry/[registry] since that is where we will push the image needed to deploy the quickstart, and where we will tell the Helm charts to download it from.

[source,options="nowrap",subs="+attributes"]
----
minikube addons enable registry
----

In order to be able to push images to the registry we need to make it accessible from outside Kubernetes. How we do this depends on your operating system. All the below examples will expose it at `localhost:5000`

[source,options="nowrap",subs="+attributes"]
----
# On Mac:
docker run --rm -it --network=host alpine ash -c "apk add socat && socat TCP-LISTEN:5000,reuseaddr,fork TCP:$(minikube ip):5000"

# On Linux:
kubectl port-forward --namespace kube-system service/registry 5000:80 &

# On Windows:
kubectl port-forward --namespace kube-system service/registry 5000:80
docker run --rm -it --network=host alpine ash -c "apk add socat && socat TCP-LISTEN:5000,reuseaddr,fork TCP:host.docker.internal:5000"
----

[[prerequisites_helm_openshift]]
== Prerequisites

ifndef::kubernetes[]
* You must be logged in OpenShift and have an `oc` client to connect to OpenShift
endif::[]
* https://helm.sh[Helm] must be installed to deploy the backend on {cloud-platform}.

Once you have installed Helm, you need to add the repository that provides Helm Charts for {productName}.

ifndef::ProductRelease,EAPXPRelease[]
[source,options="nowrap"]
----
$ helm repo add wildfly https://docs.wildfly.org/wildfly-charts/
"wildfly" has been added to your repositories
$ helm search repo wildfly
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
wildfly/wildfly         ...             ...            Build and Deploy WildFly applications on OpenShift
wildfly/wildfly-common  ...             ...            A library chart for WildFly-based applications
----
endif::[]
ifdef::ProductRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP {productVersion} applications
----
endif::[]
ifdef::EAPXPRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP XP {productVersion} applications
----
endif::[]

:leveloffset: 1

ifdef::helm-install-prerequisites-kubernetes[]
// Additional steps needed before deploying in Helm
[[deploy_helm_prerequisites]]
include::{helm-install-prerequisites-kubernetes}[leveloffset=+1]
endif::helm-install-prerequisites-kubernetes[]

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

ifndef::helmSetWildFlyArgumentPrefix[]
// For use with nested Helm charts
:helmSetWildFlyArgumentPrefix:
endif::[]
ifeval::[{useHelmChartDir} == true]
:helm_chart_values: charts
endif::[]
ifndef::useHelmChartDir[]
:helm_chart_values: -f charts/helm.yaml {helmChartName}
endif::[]
ifdef::kubernetes[]
:helm-set-build-enabled: --set {helmSetWildFlyArgumentPrefix}build.enabled=false
:helm-set-deploy-route-enabled: --set {helmSetWildFlyArgumentPrefix}deploy.route.enabled=false
:helm-set-image-name: --set {helmSetWildFlyArgumentPrefix}image.name="localhost:5000/{artifactId}"
:helm-extra-arguments: {helm-set-build-enabled} {helm-set-deploy-route-enabled} {helm-set-image-name}
:cloud-cli: kubectl
endif::[]
ifndef::kubernetes[]
:helm-extra-arguments:
:cloud-cli: oc
endif::[]
[[deploy_helm]]
== Deploy the {ProductShortName} Source-to-Image (S2I) Quickstart to {cloud-platform} with Helm Charts

ifndef::kubernetes[]
Log in to your OpenShift instance using the `oc login` command.
endif::[]
The backend will be built and deployed on {cloud-platform} with a Helm Chart for {productName}.


ifndef::kubernetes[]
Navigate to the root directory of this quickstart and run the following command:
endif::[]
ifdef::kubernetes[]
Navigate to the root directory of this quickstart and run the following commands:

[source,options="nowrap",subs="+attributes"]
----
mvn -Popenshift package wildfly:image
----
This will use the `openshift` Maven profile we saw earlier to build the application, and create a Docker image containing the {productName} server with the application deployed. The name of the image will be `{artifactId}`.

Next we need to tag the image and make it available to Kubernetes. You can push it to a registry like `quay.io`. In this case we tag as `localhost:5000/{artifactId}:latest` and push it to the internal registry in our Kubernetes instance:

[source,options="nowrap",subs="+attributes"]
----
# Tag the image
docker tag {artifactId} localhost:5000/{artifactId}:latest
# Push the image to the registry
docker push localhost:5000/{artifactId}:latest
----

In the below call to `helm install` which deploys our application to Kubernetes, we are passing in some extra arguments to tweak the Helm build:

* `{helm-set-build-enabled}` - This turns off the s2i build for the Helm chart since Kubernetes, unlike OpenShift, does not have s2i. Instead, we are providing the image to use.
* `{helm-set-deploy-route-enabled}` - This disables route creation normally performed by the Helm chart. On Kubernetes we will use port-forwards instead to access our application, since routes are an OpenShift specific concept and thus not available on Kubernetes.
* `{helm-set-image-name}` - This tells the Helm chart to use the image we built, tagged and pushed to Kubernetes' internal registry above.

endif::[]
[source,options="nowrap",subs="+attributes"]
----
$ helm install {helm-app-name} {helm_chart_values} --wait --timeout=10m0s {helm-extra-arguments}
NAME: {helm-app-name}
...
STATUS: deployed
REVISION: 1
----

This command will return once the application has successfully deployed. In case of a timeout, you can check the status of the application with the following command in another terminal:

[source,options="nowrap",subs="+attributes"]
----
{cloud-cli} get deployment {helm-app-name}
----

The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I on Java 17:


ifndef::requires-http-route[]
ifdef::useHelmChartDir[]
[source,yaml]
----
include::{docdir}/charts/Chart.yaml[]
----
endif::useHelmChartDir[]
ifndef::useHelmChartDir[]
[source,yaml]
----
build:
  uri: https://github.com/wildfly/quickstart.git
  ref: main
  contextDir: microprofile-jwt
deploy:
  replicas: 1
----
endif::useHelmChartDir[]
endif::requires-http-route[]

ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
build:
  uri: {githubRepoCodeUrl}
  ref: {WildFlyQuickStartRepoTag}
  contextDir: {artifactId}
deploy:
  replicas: 1
  route:
    tls:
      enabled: false
----
endif::requires-http-route[]

This will create a new deployment on {cloud-platform} and deploy the application.

If you want to see all the configuration elements to customize your deployment you can use the following command:
[source,options="nowrap",subs="+attributes"]
----
$ helm show readme {helmChartName}
----

ifdef::openshift[]
Get the URL of the route to the deployment.

[source,options="nowrap",subs="+attributes"]
----
$ oc get route {helm-app-name} -o jsonpath="{.spec.host}"
----
Access the application in your web browser using the displayed URL.
endif::[]
ifdef::kubernetes[]
To be able to connect to our application running in Kubernetes from outside, we need to set up a port-forward to the `{helm-app-name}` service created for us by the Helm chart.

This service will run on port `8080`, and we set up the port forward to also run on port `8080`:

[source,options="nowrap",subs="+attributes"]
----
kubectl port-forward service/{helm-app-name} 8080:8080
----
The server can now be accessed via `http://localhost:8080` from outside Kubernetes. Note that the command to create the port-forward will not return, so it is easiest to run this in a separate terminal.

endif::[]

ifdef::openshift+post-helm-install-actions-openshift[]
include::{post-helm-install-actions-openshift}[leveloffset=+1]
endif::openshift+post-helm-install-actions-openshift[]
ifdef::kubernetes+post-helm-install-actions-kubernetes[]
include::{post-helm-install-actions-kubernetes}[leveloffset=+1]
endif::kubernetes+post-helm-install-actions-kubernetes[]

:leveloffset: 1

// Testing on Openshift
:leveloffset: +1

[[run_the_integration_tests_with_kubernetes]]
= Run the Integration Tests with Kubernetes
The integration tests included with this quickstart, which verify that the quickstart runs correctly, may also be run with the quickstart running on Kubernetes.
[NOTE]
====
The integration tests expect a deployed application, so make sure you have deployed the quickstart on Kubernetes before you begin.
====

ifdef::extra-testing-actions-kubernetes[]
include::{extra-testing-actions-kubernetes}[leveloffset=+1]
endif::extra-testing-actions-kubernetes[]

ifndef::extra-test-arguments-kubernetes[:extra-test-arguments-kubernetes:]

Run the integration tests using the following command to run the `verify` goal with the `integration-testing` profile activated and the proper URL:
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=http://localhost:8080 {extra-test-arguments-kubernetes}
----


:leveloffset: 1

//Prepare Helm for Quickstart Deployment
:leveloffset: +1

[[undeploy_helm]]
== Undeploy the {ProductShortName} Source-to-Image (S2I) Quickstart from {cloud-platform} with Helm Charts

[source,options="nowrap",subs="+attributes"]
----
$ helm uninstall {helm-app-name}
----
ifdef::kubernetes[]
To stop the port forward you created earlier use:
[source,options="nowrap",subs="+attributes"]
----
$ kubectl port-forward service/{helm-app-name} 8080:8080
----
endif::[]

:leveloffset: 1

// Unset the attribute
:!kubernetes:

:leveloffset!:
endif::[]

== Conclusion

As demonstrated within this Quickstart the MicroProfile JWT specification provides an easy way to secure deployments without needing
to rely on managed server configuration.  The techniques explored in this quickstart can be used to create your own MicroProfile JWT
secured enpoints or to add MicroProfile JWT authentication to your existing deployments.
