ifdef::env-github[]
:artifactId: microprofile-config
endif::[]

//***********************************************************************************
// Enable the following flag to build README.html files for JBoss EAP product builds.
// Comment it out for WildFly builds.
//***********************************************************************************
//:ProductRelease:

//***********************************************************************************
// Enable the following flag to build README.html files for EAP XP product builds.
// Comment it out for WildFly or JBoss EAP product builds.
//***********************************************************************************
//:EAPXPRelease:

// This is a universal name for all releases
:ProductShortName: JBoss EAP
// Product names and links are dependent on whether it is a product release (CD or JBoss)
// or the WildFly project.
// The "DocInfo*" attributes are used to build the book links to the product documentation

ifdef::ProductRelease[]
// JBoss EAP release
:productName: JBoss EAP
:productNameFull: Red Hat JBoss Enterprise Application Platform
:productVersion: 8.0
:DocInfoProductNumber: {productVersion}
:WildFlyQuickStartRepoTag: 8.0.x
:productImageVersion: 8.0.0
:helmChartName: jboss-eap/eap8
endif::[]

ifdef::EAPXPRelease[]
// JBoss EAP XP release
:productName: JBoss EAP XP
:productNameFull: Red Hat JBoss Enterprise Application Platform expansion pack
:productVersion: 3.0
:DocInfoProductNumber: 7.4
:WildFlyQuickStartRepoTag: XP_3.0.0.GA
:productImageVersion: 3.0
:helmChartName: jboss-eap/eap-xp3
endif::[]

ifdef::ProductRelease,EAPXPRelease[]
:githubRepoUrl: https://github.com/jboss-developer/jboss-eap-quickstarts/
:githubRepoCodeUrl: https://github.com/jboss-developer/jboss-eap-quickstarts.git
:jbossHomeName: EAP_HOME
:DocInfoProductName: Red Hat JBoss Enterprise Application Platform
:DocInfoProductNameURL: red_hat_jboss_enterprise_application_platform
:DocInfoPreviousProductName: jboss-enterprise-application-platform
:quickstartDownloadName: {productNameFull} {productVersion} Quickstarts
:quickstartDownloadUrl: https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=appplatform&downloadType=distributions
:helmRepoName: jboss-eap
:helmRepoUrl: https://jbossas.github.io/eap-charts/
// END ifdef::ProductRelease,EAPXPRelease[]
endif::[]

ifndef::ProductRelease,EAPXPRelease[]
// WildFly project
:productName: WildFly
:productNameFull: WildFly Application Server
:ProductShortName: {productName}
:jbossHomeName: WILDFLY_HOME
:productVersion: 31
:productImageVersion: 31.0
:githubRepoUrl: https://github.com/wildfly/quickstart/
:githubRepoCodeUrl: https://github.com/wildfly/quickstart.git
:WildFlyQuickStartRepoTag: 31.0.0.Beta1
:DocInfoProductName: Red Hat JBoss Enterprise Application Platform
:DocInfoProductNameURL: red_hat_jboss_enterprise_application_platform
// Do not update the following until after the 7.4 docs are published!
:DocInfoProductNumber: 7.4
:DocInfoPreviousProductName: jboss-enterprise-application-platform
:helmRepoName: wildfly
:helmRepoUrl: http://docs.wildfly.org/wildfly-charts/
:helmChartName: wildfly/wildfly
// END ifndef::ProductRelease,EAPCDRelease,EAPXPRelease[]
endif::[]

:source: {githubRepoUrl}

// Values for Openshift S2i sections attributes
:CDProductName:  {productNameFull} for OpenShift
:CDProductShortName: {ProductShortName} for OpenShift
:CDProductTitle: {CDProductName}
:CDProductNameSentence: Openshift release for {ProductShortName}
:CDProductAcronym: {CDProductShortName}
:CDProductVersion: {productVersion}
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {EapForOpenshiftBookName} Online
:xpaasproduct: {productNameFull} for OpenShift
:xpaasproductOpenShiftOnline: {xpaasproduct} Online
:xpaasproduct-shortname: {CDProductShortName}
:xpaasproductOpenShiftOnline-shortname: {xpaasproduct-shortname} Online
:ContainerRegistryName: Red Hat Container Registry
:EapForOpenshiftBookName: Getting Started with {ProductShortName} for OpenShift Container Platform
:EapForOpenshiftOnlineBookName: Getting Started with {ProductShortName} for OpenShift Online
:OpenShiftOnlinePlatformName: Red Hat OpenShift Container Platform
:OpenShiftOnlineName: Red Hat OpenShift Online
:ImagePrefixVersion: eap80
:ImageandTemplateImportBaseURL: https://raw.githubusercontent.com/jboss-container-images/jboss-eap-openshift-templates
:ImageandTemplateImportURL: {ImageandTemplateImportBaseURL}/{ImagePrefixVersion}/
:BuildImageStream: jboss-{ImagePrefixVersion}-openjdk11-openshift
:RuntimeImageStream: jboss-{ImagePrefixVersion}-openjdk11-runtime-openshift

// OpenShift repository and reference for quickstarts
:EAPQuickStartRepo: https://github.com/jboss-developer/jboss-eap-quickstarts
:EAPQuickStartRepoRef: 8.0.x
:EAPQuickStartRepoTag: EAP_8.0.0.Beta
// Links to the OpenShift documentation
:LinkOpenShiftGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_with_jboss_eap_for_openshift_container_platform/
:LinkOpenShiftOnlineGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_with_jboss_eap_for_openshift_online/

ifdef::EAPXPRelease[]
// Attributes for XP releases
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {productNameFull} for OpenShift Online
:xpaasproduct: {productNameFull} for OpenShift
:xpaasproductOpenShiftOnline: {productNameFull} for OpenShift Online
:xpaasproduct-shortname: {ProductShortName} for OpenShift
:xpaasproductOpenShiftOnline-shortname: {ProductShortName} for OpenShift Online
:ContainerRegistryName: Red Hat Container Registry
:EapForOpenshiftBookName: {productNameFull} for OpenShift
:EapForOpenshiftOnlineBookName: {productNameFull} for OpenShift Online
:ImagePrefixVersion: eap-xp3
:ImageandTemplateImportURL: {ImageandTemplateImportBaseURL}/{ImagePrefixVersion}/
:BuildImageStream: jboss-{ImagePrefixVersion}-openjdk11-openshift
:RuntimeImageStream: jboss-{ImagePrefixVersion}-openjdk11-runtime-openshift
// OpenShift repository and reference for quickstarts
:EAPQuickStartRepoRef: xp-3.0.x
// Links to the OpenShift documentation
:LinkOpenShiftGuide: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/{DocInfoProductNumber}/html/using_eclipse_microprofile_in_jboss_eap/using-the-openshift-image-for-jboss-eap-xp_default
:LinkOpenShiftOnlineGuide: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/{DocInfoProductNumber}/html/using_eclipse_microprofile_in_jboss_eap/using-the-openshift-image-for-jboss-eap-xp_default
endif::[]

ifndef::ProductRelease,EAPCDRelease,EAPXPRelease[]
:ImageandTemplateImportURL: https://raw.githubusercontent.com/wildfly/wildfly-s2i/v{productVersion}.0/
endif::[]

//*************************
// Other values
//*************************
:buildRequirements: Java 11.0 (Java SDK 11) or later and Maven 3.6.0 or later
:jbdsEapServerName: Red Hat JBoss Enterprise Application Platform 7.3
:javaVersion: Jakarta EE 10
ifdef::EAPXPRelease[]
:javaVersion: Eclipse MicroProfile
endif::[]
:githubRepoBranch: master
:guidesBaseUrl: https://github.com/jboss-developer/jboss-developer-shared-resources/blob/master/guides/
:useEclipseUrl: {guidesBaseUrl}USE_JBDS.adoc#use_red_hat_jboss_developer_studio_or_eclipse_to_run_the_quickstarts
:useEclipseDeployJavaClientDocUrl: {guidesBaseUrl}USE_JBDS.adoc#deploy_and_undeploy_a_quickstart_containing_server_and_java_client_projects
:useEclipseDeployEARDocUrl: {guidesBaseUrl}USE_JBDS.adoc#deploy_and_undeploy_a_quickstart_ear_project
:useProductHomeDocUrl: {guidesBaseUrl}USE_OF_{jbossHomeName}.adoc#use_of_product_home_and_jboss_home_variables
:configureMavenDocUrl: {guidesBaseUrl}CONFIGURE_MAVEN_JBOSS_EAP.adoc#configure_maven_to_build_and_deploy_the_quickstarts
:arquillianTestsDocUrl: {guidesBaseUrl}RUN_ARQUILLIAN_TESTS.adoc#run_the_arquillian_tests
:addUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#create_users_required_by_the_quickstarts
:addApplicationUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#add_an_application_user
:addManagementUserDocUrl: {guidesBaseUrl}CREATE_USERS.adoc#add_an_management_user
:startServerDocUrl: {guidesBaseUrl}START_JBOSS_EAP.adoc#start_the_jboss_eap_server
:configurePostgresDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#configure_the_postgresql_database_for_use_with_the_quickstarts
:configurePostgresDownloadDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#download_and_install_postgresql
:configurePostgresCreateUserDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#create_a_database_user
:configurePostgresAddModuleDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#add_the_postgres_module_to_the_jboss_eap_server
:configurePostgresDriverDocUrl: {guidesBaseUrl}CONFIGURE_POSTGRESQL_JBOSS_EAP.adoc#configure_the_postgresql_driver_in_the_jboss_eap_server
:configureBytemanDownloadDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#download_and_configure_byteman
:configureBytemanDisableDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#disable_the_byteman_script
:configureBytemanClearDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#clear_the_transaction_object_store
:configureBytemanQuickstartDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#configure_byteman_for_use_with_the_quickstarts
:configureBytemanHaltDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#use_byteman_to_halt_the_application[
:configureBytemanQuickstartsDocUrl: {guidesBaseUrl}CONFIGURE_BYTEMAN.adoc#configure_byteman_for_use_with_the_quickstarts

:EESubsystemNamespace: urn:jboss:domain:ee:4.0
:IiopOpenJdkSubsystemNamespace: urn:jboss:domain:iiop-openjdk:2.0
:MailSubsystemNamespace: urn:jboss:domain:mail:3.0
:SingletonSubsystemNamespace: urn:jboss:domain:singleton:1.0
:TransactionsSubsystemNamespace: urn:jboss:domain:transactions:4.0

// LinkProductDocHome: https://access.redhat.com/documentation/en/red-hat-jboss-enterprise-application-platform/
:LinkProductDocHome: https://access.redhat.com/documentation/en/jboss-enterprise-application-platform-continuous-delivery
:LinkConfigGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/configuration_guide/
:LinkDevelopmentGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/development_guide/
:LinkGettingStartedGuide: https://access.redhat.com/documentation/en-us/{DocInfoProductNameURL}/{DocInfoProductNumber}/html-single/getting_started_guide/
:LinkOpenShiftWelcome: https://docs.openshift.com/online/welcome/index.html
:LinkOpenShiftSignup: https://docs.openshift.com/online/getting_started/choose_a_plan.html
:OpenShiftTemplateName: JBoss EAP CD (no https)

:ConfigBookName: Configuration Guide
:DevelopmentBookName: Development Guide
:GettingStartedBookName: Getting Started Guide

:JBDSProductName: Red Hat CodeReady Studio
:JBDSVersion: 12.15
:LinkJBDSInstall:  https://access.redhat.com/documentation/en-us/red_hat_codeready_studio/{JBDSVersion}/html-single/installation_guide/
:JBDSInstallBookName: Installation Guide
:LinkJBDSGettingStarted: https://access.redhat.com/documentation/en-us/red_hat_codeready_studio/{JBDSVersion}/html-single/getting_started_with_codeready_studio_tools/
:JBDSGettingStartedBookName: Getting Started with CodeReady Studio Tools

= microprofile-config: MicroProfile Config QuickStart
:author: Martin Stefanko
:level: Beginner
:technologies: MicroProfile Config

[abstract]
The `microprofile-config` quickstart demonstrates the use of the MicroProfile Config specification in {productName}.

:standalone-server-type: microprofile
:archiveType: war
:archiveName: {artifactId}
:arq-prerequisities: These tests require that JBOSS_HOME environment variable is set.

== What is it?

MicroProfile Config allows users to externalize their configuration from their
application code. Users can modify the configuration from outside of the application
so they can change it without the need to rebuild their applications. It exposes the
configuration values to the application code through the CDI injection.

== Architecture

In this quickstart, we have a collection of CDI beans that expose functionalities of
the MicroProfile Config specification. The individual externally configured values
are provided to the users through a set of REST endpoints.

// Link to the quickstart source
:leveloffset: +1

ifndef::ProductRelease,EAPXPRelease[]
link:https://github.com/wildfly/quickstart/tree/{WildFlyQuickStartRepoTag}/{artifactId}[Browse the source]
endif::[]

:leveloffset!:
// System Requirements
:leveloffset: +1

[[system_requirements]]
= System Requirements
//******************************************************************************
// Include this template to describe the standard system requirements for
// running the quickstarts.
//
// The Forge quickstarts define a `forge-from-scratch` attribute because they
// run entirely in CodeReady Studio and have different requirements .
//******************************************************************************

The application this project produces is designed to be run on {productNameFull} {productVersion} or later.

All you need to build this project is {buildRequirements}. See link:{configureMavenDocUrl}[Configure Maven to Build and Deploy the Quickstarts] to make sure you are configured correctly for testing the quickstarts.

:leveloffset!:

// Use of {jbossHomeName}
:leveloffset: +1

ifdef::requires-multiple-servers[]
[[use_of_jboss_home_name]]
= Use of the {jbossHomeName}_1, {jbossHomeName}_2, and QUICKSTART_HOME Variables

This quickstart requires that you clone your `__{jbossHomeName}__` installation directory and run two servers. The installation path is described in detail here: link:{useProductHomeDocUrl}[Use of __{jbossHomeName}__ and __JBOSS_HOME__ Variables].

In the following instructions, replace `__{jbossHomeName}_1__` with the path to your first {productName} server and replace `__{jbossHomeName}_2__` with the path to your second cloned {productName} server.

When you see the replaceable variable __QUICKSTART_HOME__, replace it with the path to the root directory of all of the quickstarts.
endif::[]

ifdef::optional-domain-or-multiple-servers[]
[[use_of_jboss_home_name]]
= Use of the {jbossHomeName}_1, {jbossHomeName}_2, and QUICKSTART_HOME Variables

When deploying this quickstart to a managed domain, replace `__{jbossHomeName}__` with the actual path to your {productName} installation. The installation path is described in detail here: link:{useProductHomeDocUrl}[Use of __{jbossHomeName}__ and __JBOSS_HOME__ Variables].

When deploying this quickstart to multiple standalone servers, this quickstart requires that you clone your `__{jbossHomeName}__` installation directory and run two servers. In the following instructions, replace `__{jbossHomeName}_1__` with the path to your first {productName} server and replace `__{jbossHomeName}_2__` with the path to your second cloned {productName} server.

When you see the replaceable variable __QUICKSTART_HOME__, replace it with the path to the root directory of all of the quickstarts.
endif::[]

ifndef::requires-multiple-servers,optional-domain-or-multiple-servers[]
[[use_of_jboss_home_name]]
= Use of the {jbossHomeName} and QUICKSTART_HOME Variables

In the following instructions, replace `__{jbossHomeName}__` with the actual path to your {productName} installation. The installation path is described in detail here: link:{useProductHomeDocUrl}[Use of __{jbossHomeName}__ and __JBOSS_HOME__ Variables].

When you see the replaceable variable __QUICKSTART_HOME__, replace it with the path to the root directory of all of the quickstarts.
endif::[]

:leveloffset!:

// Start the {productName} Standalone Server
:leveloffset: +1

[[start_the_eap_standalone_server]]
= Start the {productName} Standalone Server
//******************************************************************************
// Include this template if your quickstart requires a normal start of a single
// standalone server.
//
// You must define the `standalone-server-type`. Supported values are:
//    default
//    full
//    full-ha
//    ha
//    custom
//
// * For mobile applications, you can define the `mobileApp` variable in the
//   `README.adoc` file to add `-b 0.0.0.0` to the command line. This allows
//    external clients, such as phones, tablets, and desktops, to connect
//    to the application through through your local network
//    ::mobileApp: {artifactId}-service
//
//******************************************************************************

//******************************************************************************
// This template sets attributes for the different standalone server profiles.
//
// You must define the `standalone-server-type`. Supported values are:
//    default
//    full
//    full-ha
//    ha
//    microprofile
//    custom
//******************************************************************************

// Standalone server with the default profile.
ifeval::["{standalone-server-type}"=="default"]
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::[]

// Standalone server with the full profile.
ifeval::["{standalone-server-type}"=="full"]
:serverProfile: full profile
:configFileName: standalone/configuration/standalone-full.xml
:serverArguments:  -c standalone-full.xml
endif::[]

// Standalone server with the full HA profile.
ifeval::["{standalone-server-type}"=="full-ha"]
:serverProfile: full HA profile
:configFileName: standalone/configuration/standalone-full-ha.xml
:serverArguments:  -c standalone-full-ha.xml
endif::[]

// Start the standalone server with the HA profile.
ifeval::["{standalone-server-type}"=="ha"]
:serverProfile: HA profile
:configFileName: standalone/configuration/standalone-ha.xml
:serverArguments:  -c standalone-ha.xml
endif::[]

// Start the standalone server with the Eclipse MicroProfile profile.
ifeval::["{standalone-server-type}"=="microprofile"]
:serverProfile: MicroProfile profile
:configFileName: standalone/configuration/standalone-microprofile.xml
:serverArguments:  -c standalone-microprofile.xml
endif::[]

// Standalone server with the custom profile.
// NOTE: This profile requires that you define the `serverArguments` variable
// within the quickstart README.adoc file. For example:
//  :serverArguments: --server-config=../../docs/examples/configs/standalone-xts.xml
ifeval::["{standalone-server-type}"=="custom"]
:serverProfile: custom profile
endif::[]

// If there is no match, use the default profile.
ifndef::serverProfile[]
:standalone-server-type:  default
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::serverProfile[]

. Open a terminal and navigate to the root of the {productName} directory.
. Start the {productName} server with the {serverProfile} by typing the following command.
+
ifdef::uses-jaeger[]
[source,subs="+quotes,attributes+",options="nowrap"]
----
$ __JAEGER_REPORTER_LOG_SPANS=true JAEGER_SAMPLER_TYPE=const JAEGER_SAMPLER_PARAM=1__ __{jbossHomeName}__/bin/standalone.sh {serverArguments}
----
endif::[]
ifndef::uses-jaeger[]
[source,subs="+quotes,attributes+",options="nowrap"]
----
$ __{jbossHomeName}__/bin/standalone.sh {serverArguments}
----
endif::[]
+
NOTE: For Windows, use the `__{jbossHomeName}__\bin\standalone.bat` script.

ifdef::mobileApp[]
+
Adding `-b 0.0.0.0` to the above command allows external clients, such as phones, tablets, and desktops, to connect through your local network. For example:
+
[source,subs="+quotes,attributes+",options="nowrap"]
----
$ __{jbossHomeName}__/bin/standalone.sh {serverArguments} -b 0.0.0.0
----
endif::[]

:leveloffset!:

== Solution

We recommend that you follow the instructions that
<<creating-new-project, create the application step by step>>. However, you can
also go right to the completed example which is available in this directory.

// Build and Deploy the Quickstart
:leveloffset: +1

[[build_and_deploy_the_quickstart]]
= Build and Deploy the Quickstart
//******************************************************************************
// Include this template if your quickstart does a normal deployment of a archive.
//
// * Define the `archiveType` variable in the quickstart README file.
//   Supported values:
//    :archiveType: ear
//    :archiveType: war
//    :archiveType: jar
//
// * To override the archive name, which defaults to the {artifactId),
//   define the `archiveName` variable, for example:
//    :archiveName: {artifactId}-service
//
// * To override the archive output directory,
//   define the `archiveDir` variable, for example:
//    :archiveDir: ear/target
//
// * To override the Maven command, define the `mavenCommand` variable,
//   for example:
//    :mavenCommand: clean install wildfly:deploy
//******************************************************************************

// The archive name defaults to the artifactId if not overridden
ifndef::archiveName[]
:archiveName: {artifactId}
endif::archiveName[]

// The archive type defaults to war if not overridden
ifndef::archiveType[]
:archiveType: war
endif::archiveType[]

// Define the archive file name as the concatenation of "archiveName" + "." + "archiveType+
:archiveFileName: {archiveName}.{archiveType}

// If they have not defined the target archive directory, make it the default for the archive type.
ifndef::archiveDir[]

ifeval::["{archiveType}"=="ear"]
:archiveDir: {artifactId}/ear/target
endif::[]

ifeval::["{archiveType}"=="war"]
:archiveDir: {artifactId}/target
endif::[]

ifeval::["{archiveType}"=="jar"]
:archiveDir: {artifactId}/target
endif::[]

endif::archiveDir[]

ifndef::mavenCommand[]
ifeval::["{archiveType}"=="ear"]
:mavenCommand: clean install
endif::[]

ifeval::["{archiveType}"=="war"]
:mavenCommand: clean package
endif::[]

ifeval::["{archiveType}"=="jar"]
:mavenCommand: clean install
endif::[]

endif::mavenCommand[]

. Make sure you xref:start_the_eap_standalone_server[start the {productName} server] as described above.
. Open a terminal and navigate to the root directory of this quickstart.
ifdef::reactive-messaging[]
. Run this command to enable the MicroProfile Reactive Messaging functionality on the server
+
[source,subs="attributes+",options="nowrap"]
----
$ __{jbossHomeName}__/bin/jboss-cli.sh --connect --file=enable-reactive-messaging.cli
----
endif::reactive-messaging[]
. Type the following command to build the quickstart.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn {mavenCommand}
----

. Type the following command to deploy the quickstart.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn wildfly:deploy
----

ifdef::rest-client-qs[]
This builds and deploys the `country-server` and `country-client` to the running instance of the server.

You should see a message in the server log indicating that the archives deployed successfully.
endif::[]
ifndef::rest-client-qs[]
This deploys the `{archiveDir}/{archiveFileName}` to the running instance of the server.

You should see a message in the server log indicating that the archive deployed successfully.
endif::[]


:leveloffset!:

// Server Distribution Testing
:leveloffset: +2

[[run_the_integration_tests_with_server_distribution]]
= Run the Integration Tests
This quickstart includes integration tests, which are located under the  `src/test/` directory. The integration tests verify that the quickstart runs correctly when deployed on the server.

Follow these steps to run the integration tests.

. Make sure you start the {productName} server, as previously described.

. Make sure you build and deploy the quickstart, as previously described.

. Type the following command to run the `verify` goal with the `integration-testing` profile activated.
+
[source,options="nowrap"]
----
$ mvn verify -Pintegration-testing
----

[NOTE]
====
You may also use the environment variable `SERVER_HOST` or the system property `server.host` to define the target URL of the tests.
====

:leveloffset!:

// Undeploy the Quickstart
:leveloffset: +1

[[undeploy_the_quickstart]]
= Undeploy the Quickstart

//*******************************************************************************
// Include this template if your quickstart does a normal undeployment of an archive.
//*******************************************************************************
When you are finished testing the quickstart, follow these steps to undeploy the archive.

. Make sure you xref:start_the_eap_standalone_server[start the {productName} server] as described above.
. Open a terminal and navigate to the root directory of this quickstart.
. Type this command to undeploy the archive:
+
[source,options="nowrap"]
----
$ mvn wildfly:undeploy
----

:leveloffset!:

[[creating-new-project]]
== Creating the Maven Project

[source,options="nowrap"]
----
mvn archetype:generate \
    -DgroupId=org.wildfly.quickstarts \
    -DartifactId=microprofile-config \
    -DinteractiveMode=false \
    -DarchetypeGroupId=org.apache.maven.archetypes \
    -DarchetypeArtifactId=maven-archetype-webapp
cd microprofile-config
----

Open the project in your favourite IDE.

Open the generated `pom.xml`:

The first thing to do is to setup our dependencies. Add the following section to your
`pom.xml`:

[source,xml,subs="attributes+"]
----
<dependencyManagement>
  <dependencies>
    <!-- importing the microprofile BOM adds MicroProfile specs -->
    <dependency>
        <groupId>org.wildfly.bom</groupId>
        <artifactId>wildfly-microprofile</artifactId>
        <version>{versionMicroprofileBom}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
----

Now we need to add the following two dependencies:

[source,xml]
----
<!-- Import the MicroProfile Config API, we use provided scope as the API is included in the server -->
<dependency>
  <groupId>org.eclipse.microprofile.config</groupId>
  <artifactId>microprofile-config-api</artifactId>
  <scope>provided</scope>
</dependency>
<!-- Import the CDI API, we use provided scope as the API is included in the server -->
<dependency>
  <groupId>jakarta.enterprise</groupId>
  <artifactId>jakarta.enterprise.cdi-api</artifactId>
  <scope>provided</scope>
</dependency>
<!-- Import the Jakarta REST API, we use provided scope as the API is included in the server -->
<dependency>
  <groupId>jakarta.ws.rs</groupId>
  <artifactId>jakarta.ws.rs-api</artifactId>
  <scope>provided</scope>
</dependency>
----

NOTE: Because MicroProfile Config uses CDI injection to expose configuration values
to the user application we need to also include the CDI API dependency.

All dependencies can have provided scope.

As we are going to be deploying this application to the {productName} server, let's
also add a maven plugin that will simplify the deployment operations (you can replace
the generated build section):

[source,xml]
----
<build>
  <!-- Set the name of the archive -->
  <finalName>${project.artifactId}</finalName>
  <plugins>
    <!-- Allows to use mvn wildfly:deploy -->
    <plugin>
      <groupId>org.wildfly.plugins</groupId>
      <artifactId>wildfly-maven-plugin</artifactId>
    </plugin>
  </plugins>
</build>
----

// Setup required repositories
:leveloffset: +1

Setup the required Maven repositories (if you don't have them set up in Maven global settings):

[source,xml]
----
<repositories>
    <repository>
        <id>jboss-public-maven-repository</id>
        <name>JBoss Public Maven Repository</name>
        <url>https://repository.jboss.org/nexus/content/groups/public</url>
        <layout>default</layout>
        <releases>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </releases>
        <snapshots>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </snapshots>
    </repository>
    <repository>
        <id>redhat-ga-maven-repository</id>
        <name>Red Hat GA Maven Repository</name>
        <url>https://maven.repository.redhat.com/ga/</url>
        <layout>default</layout>
        <releases>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </releases>
        <snapshots>
            <enabled>true</enabled>
            <updatePolicy>never</updatePolicy>
        </snapshots>
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
        <id>jboss-public-maven-repository</id>
        <name>JBoss Public Maven Repository</name>
        <url>https://repository.jboss.org/nexus/content/groups/public</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>redhat-ga-maven-repository</id>
        <name>Red Hat GA Maven Repository</name>
        <url>https://maven.repository.redhat.com/ga/</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
</pluginRepositories>
----

:leveloffset!:

As this is a Jakarta REST application we need to also create an application class.
Create `org.wildfly.quickstarts.microprofile.config.JaxRsApplication` with the following content:

NOTE: The new file should be created in
`src/main/java/org/quickstarts/microprofile/config/JaxRsApplication.java`.

[source,java]
----
package org.wildfly.quickstarts.microprofile.config;

import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/")
public class JaxRsApplication extends Application {
}
----

Now we are ready to start working with MicroProfile Config.

== Injecting a configuration value

Let's start by creating a new CDI bean which will use for the injection of our
configuration values. This CDI bean will also be a JAX-RS resource. Create a new
class `org.wildfly.quickstarts.microprofile.config.ConfigResource`;

To inject any configuration value, MicroProfile Config provides a custom qualifier
`ConfigProperty`:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/config")
@ApplicationScoped
public class ConfigResource {

    @Inject
    @ConfigProperty(name = "config.prop")
    private String configValue;

    @GET
    @Path("/value")
    public String getValue() {
        return configValue;
    }
}
----

As you can see, we are injecting a `String` configuration value named `config.prop`
directly into our CDI bean (annotated with `@ApplicationScoped`) which is also at the
same time a REST endpoint.

Let's try to deploy this application to the application server. There are several
ways of how you can specify the value of your configuration properties which the
specification calls config sources. By default each MicroProfile Config
implementation must provide at least three default config sources:

* System properties
* Environment properties
* META-INF/microprofile-config.properties file

If the same configuration value is defined by several config sources at the same
time, it is resolved based on the config sources priority. The default config
sources are prioritized in descending order (system properties, environment
properties, and microprofile-config.properties). So we look for the configuration
value in the environment properties only if we cannot find it in the system
properties.

Now we can start configuring our application. As specified above, the lowest
ranking of the default config sources has the microprofile-config.properties file.
So let's create a new file in our
`src/main/resources/META-INF/microprofile-config.properties` with the following
content:

[source,properties]
----
config.prop=MyPropertyFileConfigValue
----

Now we can test our application correctly recognizes the configuration value:

* Start your {productName} server

* Package and deploy your application:

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

To check that the {productName} is working as expected:

* access the `http://localhost:8080/microprofile-config/config/value`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/config/value`

You will see that the returned value is our configured system property
`MyPropertyFileConfigValue`.

As said above, there are three different default config sources. So far we have
seen only the `microprofile-config.properties` file which has the lowest priority.
Let's override our configuration value with an environment property which has
a bigger priority:

* Stop you {productName} server

* Set the environment propety `CONFIG_PROP` (the name is defined by the
specification): `export CONFIG_PROP=MyEnvPropConfigValue`

* Start your {productName} server again

* access the `http://localhost:8080/microprofile-config/config/value`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/config/value`

You can see that our configuration value defined in the configuration file was
now overridden by the environment property and the value `MyEnvPropConfigValue`
is returned.

The last default config source is the system properties which has the highest
priority:

* Stop you {productName} server

* Start your {productName} server with the `-Dconfig.prop=MySysPropConfigValue`

* access the `http://localhost:8080/microprofile-config/config/value`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/config/value`

The configuration property was overriden again and the value `MySysPropConfigValue`
is returned.

We covered the basic injection and the default config sources provided by the
MicroProfile Config specification. Let's see what else the MicroProfile Config can
offer.

== Different types of configuration injections and default values

In our first example we injected a concrete `String` value:

[source,java]
----
@Inject
@ConfigProperty(name = "config.prop")
private String configValue;
----

The `ConfigProperty` qualifier contains one more optional parameter called the
`defaultValue`. As the name says, this parameter sets the default value if the
configuration property is not found in any of the config sources.

To demonstrate how this works, let's define a new configuration property without
the default value:

* Add the following code to `org.wildfly.quickstarts.microprofile.config.ConfigResource`:

[source,java]
----
@Inject
@ConfigProperty(name = "required.prop")
private String requiredProp;

@GET
@Path("/required")
public String getRequiredProp() {
    return requiredProp;
}
----

* Build and redeploy the application

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

The deployment will fail with the following error:

```
Caused by: org.jboss.weld.exceptions.DeploymentException: No Config Value exists for required property required.prop
```

because the required configuration property `required.prop` wasn't defined. Let's
fix this by providing a default value for this property if it's not found in any
of the config sources:

[source,java]
----
@Inject
@ConfigProperty(name = "required.prop", defaultValue = "Default required prop value")
private String requiredProp;
----

Build and redeploy the application

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

The application should now deploy without any errors and if access the
`http://localhost:8080/microprofile-config/config/required` endpoint
using your browser or
`curl http://localhost:8080/microprofile-config/config/required` you
will see the default value that we configured in the `ConfigProperty` qualifier.

However, this is not the only way how you can deal with the situation when the
configuration value is not provided. MicroProfile Config allows you to define
different types of injections:

* concrete values (String, int, double, ...) -- see the default converters later
* optional values (Optional<T>) -- if the value is not found the specification
injects `Optional.empty()` so the application can still be successfully deployed
even if the configuration property is undefined
* always reloaded values (Provider<T>) -- the value will be reevaluated with every
access (see later with custom config sources)

Let's add a new configuration property `optional.prop` with the type
`Optional<String>` and corresponding endpoint:

[source,java]
----
@Inject
@ConfigProperty(name = "optional.prop")
private Optional<String> optionalString;

@GET
@Path("/optional")
public String getOptionalValue() {
    return optionalString.orElse("no optional value provided, use this as the default");
}
----

Build and redeploy the application

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

If you now access the
`http://localhost:8080/microprofile-config/config/optional` endpoint
using your browser or
`curl http://localhost:8080/microprofile-config/config/optional` you
will get back the `orElse` value because the `optional.prop` was not defined
in our config sources.

Last but not least, MicroProfile Config also allows you to inject the whole
configuration collected from all config sources as a single object instance of
the `Config` interface which provides a programmatic access to the configuration.
Add the following code to `org.wildfly.quickstarts.microprofile.config.ConfigResource`:

[source,java]
----
@Inject
private Config config;

@GET
@Path("/all-props")
public String getConfigPropertyNames() {
    return config.getPropertyNames().toString();
}
----

Build and redeploy the application

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

Access the `http://localhost:8080/microprofile-config/config/all-props`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/config/all-props` and
you will see all available configuration property names.

NOTE: You can investigate also the other methods of the `Config` interface.

== Custom configuration sources

MicroProfile Config allows you to define your own custom configuration sources
to extend the three default ones provided by the implementation. To define your
custom configuration source you need to provide a class which implements either
`org.eclipse.microprofile.config.spi.ConfigSource` or
`org.eclipse.microprofile.config.spi.ConfigSourceProvider` and define it through
the https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file]
which will be detected and installed at application startup/deployment.

Let's define a custom config source with some predefined values. First create
a new REST resource
`org.wildfly.quickstarts.microprofile.config.CustomConfigResource` which will be enclosing
our custom configurations:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/custom-config")
public class CustomConfigResource {

    @Inject
    @ConfigProperty(name = "custom.config.source.prop")
    private String customConfigSourceProp;

    @GET
    @Path("/value")
    public String getCustomConfigSourceProp() {
        return customConfigSourceProp;
    }
}
----

Let's now define a custom configuration source that will provide
`custom.config.source.prop` configuration property. Create a new class
`org.wildfly.quickstarts.microprofile.config.custom.CustomConfigSource`:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config.custom;

import org.eclipse.microprofile.config.spi.ConfigSource;

import java.util.HashMap;
import java.util.Map;

public class CustomConfigSource implements ConfigSource {

    private final Map<String, String> properties;

    public CustomConfigSource() {
        properties = new HashMap<>();
        properties.put("custom.config.source.prop", "MyCustomValue");
    }

    @Override
    public Map<String, String> getProperties() {
        return properties;
    }

    @Override
    public String getValue(String propertyName) {
        return properties.get(propertyName);
    }

    @Override
    public String getName() {
        return "Custom Config Source with predefined values";
    }

    @Override
    public int getOrdinal() {
        return 400;
    }
}
----

We only need to override the necessary methods required to get the properties and
to set the config source name. In this example, we also override the `getOrdinal`
method which sets the config source priority to be higher than any of the default
config sources.

The last thing we need to do is to include our custom configuration source service
loader definition. Create
`src/main/resources/META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource`
with the following content:
`org.wildfly.quickstarts.microprofile.config.custom.CustomConfigSource`.

Build and redeploy the application

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

If you now access the
`http://localhost:8080/microprofile-config/custom-config/value`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/custom-config/value`
you will get back the configuration value `MyCustomValue` defined in our custom
configuration source.

If you would like to have a more programmatic approach to the definition of
different ``ConfigSource``s, you can use
`org.eclipse.microprofile.config.spi.ConfigSourceProvider`. Let's create a
`ConfigSourceProvider` that defines a dynamic `ConfigSource`. Create a new class
`org.wildfly.quickstarts.microprofile.config.custom.CustomPropertiesFileProvider`:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config.custom;

import org.eclipse.microprofile.config.spi.ConfigSource;
import org.eclipse.microprofile.config.spi.ConfigSourceProvider;

import java.io.FileInputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.stream.Collectors;

public class CustomPropertiesFileProvider implements ConfigSourceProvider {

    @Override
    public Iterable<ConfigSource> getConfigSources(ClassLoader forClassLoader) {
        List<ConfigSource> configSources = new ArrayList<>();

        configSources.add(new ConfigSource() {
            @Override
            public Map<String, String> getProperties() {
                return reloadPropertiesFile();
            }

            @Override
            public String getValue(String propertyName) {
                return reloadPropertiesFile().get(propertyName);
            }

            @Override
            public String getName() {
                return "Custom dynamic configuration source";
            }
        });

        return configSources;
    }

    private Map<String, String> reloadPropertiesFile() {
        Properties properties = new Properties();
        Path customPropertiesPath = Paths.get(System.getenv("JBOSS_HOME") + "/custom.properties");

        if (!Files.exists(customPropertiesPath)) {
            return new HashMap<>();
        }

        try (FileInputStream is = new FileInputStream(customPropertiesPath.toFile())) {
            properties.load(is);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return properties.entrySet().stream().collect(
            Collectors.toMap(
                entry -> entry.getKey().toString(),
                entry -> entry.getValue().toString()
            )
        );
    }
}
----

IMPORTANT: This requires that the `JBOSS_HOME` environment variable is set.

NOTE: Note that our new custom `ConfigSource` reloads the property file on every
access.

As you can see above, our custom configuration source is accessing a file
named `custom.properties` which needs to be created in your {productName}
root directory (`JBOSS_HOME`):

[source,properties]
----
custom.provided.prop=FileSystemCustomConfigValue
----

And as previously we need the service loader definition
`src/main/resources/META-INF/services/org.eclipse.microprofile.config.spi.ConfigSourceProvider`
with the content:
`org.wildfly.quickstarts.microprofile.config.custom.CustomPropertiesFileProvider`.

Let's define a new endpoint for accessing this custom dynamic config source.
Add the following code to the
`org.wildfly.quickstarts.microprofile.config.CustomConfigResource`:

[source,java]
----
@Inject
@ConfigProperty(name = "custom.provided.prop", defaultValue = "default")
private Provider<String> providedCustomProp;

@GET
@Path("/reloaded-value")
public String providedCustomProp() {
    return providedCustomProp.get();
}
----

Note that we are now using `jakarta.inject.Provider` as an injected type. This means
that our value will be reloaded from config sources on every access. Since we are
reloading the property file from the file system on every access this allows us to
change the configuration dynamically without the need to restart the {productName}
server or to redeploy the application.

Build and redeploy the application:

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

If you now access the
`http://localhost:8080/microprofile-config/custom-config/reloaded-value`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/custom-config/reloaded-value`
you will get back the configuration value `FileSystemCustomConfigValue` defined
in our custom configuration file. But if you now change the `custom.properties`
file (without stopping of the server or the need to redeploy the application)
and repeat the invocation at
`http://localhost:8080/microprofile-config/custom-config/reloaded-value`
you will see that the value is dynamically reloaded:

* change `$JBOSS_HOME/custom.properties` (don't forget to save the file):

[source,properties]
----
custom.provided.prop=DynamicallyUpdatedValue
----

* repeat the invocation at
`http://localhost:8080/microprofile-config/custom-config/reloaded-value`

You will see that the value `DynamicallyUpdatedValue` is returned. If you repeat
this with different values of `custom.provide.prop` it will always get reloaded.

== Custom configuration converters

The MicroProfile Config provides several default converters from the configuration
values which are typed as ``String``s (e.g. `int`, `Integer`, `Double`, `float`, ...).
However, you can also use your custom types as a configuration values. This can be
done by implementing
`org.eclipse.microprofile.config.spi.Converter<T>` and adding its fully qualified
class name in the
`META-INF/services/org.eclipse.microprofile.config.spi.Converter` file. Let's create
a new class
`org.wildfly.quickstarts.microprofile.config.converter.type.MicroProfileCustomValue`:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config.converter.type;

public class MicroProfileCustomValue {

    private String name;

    public MicroProfileCustomValue(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
----

which represents our custom value and the corresponding
`Converter<MicroProfileCustomValue>` implementation
`org.wildfly.quickstarts.microprofile.config.converter.MicroProfileCustomValueConverter`:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config.converter;

import org.eclipse.microprofile.config.spi.Converter;
import org.wildfly.quickstarts.microprofile.config.converter.type.MicroProfileCustomValue;

public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {

    @Override
    public MicroProfileCustomValue convert(String value) {
        return new MicroProfileCustomValue(value);
    }
}
----

NOTE: Please note that your custom converter class must be public and must have a
public no-argument constructor. It also must not be abstract.

Then you need to include the fully qualified class name of the converter in a
service file
`src/main/resources/META-INF/services/org.eclipse.microprofile.config.spi.Converter`:

[source]
----
org.wildfly.quickstarts.microprofile.config.converter.MicroProfileCustomValueConverter
----

After this is done you can use your custom type as a configuration value. Create
a new resource class `org.wildfly.quickstarts.microprofile.config.ConverterResource`:

[source,java]
----
package org.wildfly.quickstarts.microprofile.config;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.wildfly.quickstarts.microprofile.config.converter.type.MicroProfileCustomValue;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/converter")
public class ConverterResource {

    @Inject
    @ConfigProperty(name = "custom.converter.prop")
    private MicroProfileCustomValue microProfileCustomValue;

    @GET
    @Path("/value")
    public String customConverterProp() {
        return microProfileCustomValue.getName();
    }
}
----

And define the `custom.converter.prop` in, for instance,
`microprofile-config.properties` file.

[source,properties]
----
custom.converter.prop=MyCustomConverterValue
----

Build and redeploy the application

[source,options="nowrap"]
----
$ mvn clean package wildfly:deploy
----

And now you can access the
`http://localhost:8080/microprofile-config/converter/value`
endpoint using your browser or
`curl http://localhost:8080/microprofile-config/converter/value` to make use of the custom
converter. You will see the configured value which is taken from our created
`MicroProfileCustomValue` object.

// Bootable JAR
:leveloffset: +1

[[build_and_run_the_quickstart_with_bootable_jar]]
= Building and running the quickstart application in a bootable JAR

You can use the WildFly JAR Maven plug-in to build a {productName} bootable JAR to run this quickstart.

The quickstart `pom.xml` file contains a Maven profile named *bootable-jar* which configures the bootable JAR building:

[source,xml,subs="attributes+"]
----
      <profile>
          <id>bootable-jar</id>
          <build>
              <plugins>
                  <plugin>
                      <groupId>org.wildfly.plugins</groupId>
                      <artifactId>wildfly-jar-maven-plugin</artifactId>
                      <configuration>
                          <feature-pack-location>wildfly@maven(org.jboss.universe:community-universe)#${version.server}</feature-pack-location>
                          <layers>...</layers>
                          <plugin-options>
                              <jboss-fork-embedded>true</jboss-fork-embedded>
                          </plugin-options>
                      </configuration>
                      <executions>
                          <execution>
                              <goals>
                                  <goal>package</goal>
                              </goals>
                          </execution>
                      </executions>
                  </plugin>
                  ...
              </plugins>
          </build>
      </profile>
----

.Procedure

. Build the quickstart bootable JAR with the following command:
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn clean package -Pbootable-jar
----

. Run the quickstart application contained in the bootable JAR:
+
[source,subs="attributes+",options="nowrap"]
----
ifdef::uses-jaeger[]
$ JAEGER_REPORTER_LOG_SPANS=true JAEGER_SAMPLER_TYPE=const JAEGER_SAMPLER_PARAM=1 java -jar target/{artifactId}-bootable.jar
endif::uses-jaeger[]
ifndef::uses-jaeger[]
$ java -jar target/{artifactId}-bootable.jar
endif::uses-jaeger[]
----

. You can now interact with the quickstart application.

[NOTE]
====
After the quickstart application is deployed, the bootable JAR includes the application in the root context. Therefore, any URLs related to the application should not have the `/{artifactId}` path segment after `HOST:PORT`.
====

// Bootable Jar Testing
:leveloffset: +1

[[run_the_integration_tests_with_bootable_jar_]]
= Run the Integration Tests with a bootable jar

//******************************************************************************
// This template sets attributes for the different standalone server profiles.
//
// You must define the `standalone-server-type`. Supported values are:
//    default
//    full
//    full-ha
//    ha
//    microprofile
//    custom
//******************************************************************************

// Standalone server with the default profile.
ifeval::["{standalone-server-type}"=="default"]
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::[]

// Standalone server with the full profile.
ifeval::["{standalone-server-type}"=="full"]
:serverProfile: full profile
:configFileName: standalone/configuration/standalone-full.xml
:serverArguments:  -c standalone-full.xml
endif::[]

// Standalone server with the full HA profile.
ifeval::["{standalone-server-type}"=="full-ha"]
:serverProfile: full HA profile
:configFileName: standalone/configuration/standalone-full-ha.xml
:serverArguments:  -c standalone-full-ha.xml
endif::[]

// Start the standalone server with the HA profile.
ifeval::["{standalone-server-type}"=="ha"]
:serverProfile: HA profile
:configFileName: standalone/configuration/standalone-ha.xml
:serverArguments:  -c standalone-ha.xml
endif::[]

// Start the standalone server with the Eclipse MicroProfile profile.
ifeval::["{standalone-server-type}"=="microprofile"]
:serverProfile: MicroProfile profile
:configFileName: standalone/configuration/standalone-microprofile.xml
:serverArguments:  -c standalone-microprofile.xml
endif::[]

// Standalone server with the custom profile.
// NOTE: This profile requires that you define the `serverArguments` variable
// within the quickstart README.adoc file. For example:
//  :serverArguments: --server-config=../../docs/examples/configs/standalone-xts.xml
ifeval::["{standalone-server-type}"=="custom"]
:serverProfile: custom profile
endif::[]

// If there is no match, use the default profile.
ifndef::serverProfile[]
:standalone-server-type:  default
:serverProfile: default profile
:configFileName: standalone/configuration/standalone.xml
:serverArguments:
endif::serverProfile[]
ifndef::server_provisioning_server_host[:server_provisioning_server_host: http://localhost:8080]

The integration tests included with this quickstart, which verify that the quickstart runs correctly, may also be run with a bootable jar.

Follow these steps to run the integration tests.

. Make sure the bootable jar is provisioned.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn clean package -Pbootable-jar
----

. Start the {productName} bootable jar, this time using the {productName} Maven Jar Plugin, which is recommend for testing due to simpler automation.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn wildfly-jar:start -Djar-file-name=target/{artifactId}-bootable.jar
----

. Type the following command to run the `verify` goal with the `integration-testing` profile activated, and specifying the quickstart's URL using the `server.host` system property, which for a bootable jar by default is `{server_provisioning_server_host}`.
+
[source,subs="attributes+",options="nowrap"]
----
$ mvn verify -Pintegration-testing -Dserver.host={server_provisioning_server_host}
----

. Shutdown the {productName} bootable jar, this time using the {productName} Maven Jar Plugin too.
+
[source,options="nowrap"]
----
$ mvn wildfly-jar:shutdown
----

:leveloffset: 1

:leveloffset!:

// Openshift
:leveloffset: +1

ifndef::helm-app-name[]
:helm-app-name: {artifactId}
endif::helm-app-name[]



[[build_and_run_the_quickstart_on_openshift]]
= Building and running the quickstart application with OpenShift
// The openshift profile
:leveloffset: +1

[[build-the-quickstart-for-openshift]]
== Build the {productName} Source-to-Image (S2I) Quickstart to OpenShift with Helm Charts

On OpenShift, the S2I build with Apache Maven uses an `openshift` Maven profile to provision a {productName} server, deploy and run the quickstart in OpenShift environment.

ifndef::ProductRelease,EAPXPRelease[]
The server provisioning functionality is provided by the WildFly Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
endif::[]
ifdef::ProductRelease,EAPXPRelease[]
The server provisioning functionality is provided by the EAP Maven Plugin, and you may find its configuration in the quickstart `pom.xml`:
endif::[]

ifndef::ProductRelease,EAPXPRelease[]
[source,xml,subs="attributes+"]
----
        <profile>
            <id>openshift</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.wildfly.plugins</groupId>
                        <artifactId>wildfly-maven-plugin</artifactId>
                        <configuration>
                            <feature-packs>
                                <feature-pack>
                                    <location>org.wildfly:wildfly-galleon-pack:${version.server}</location>
                                </feature-pack>
                                <feature-pack>
                                    <location>org.wildfly.cloud:wildfly-cloud-galleon-pack:${version.pack.cloud}</location>
                                </feature-pack>
                            </feature-packs>
                            <layers>...</layers>
                            <name>ROOT.war</name>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>package</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    ...
                </plugins>
            </build>
        </profile>
----
endif::[]

ifdef::ProductRelease,EAPXPRelease[]
[source,xml,subs="attributes+"]
----
        <profile>
            <id>openshift</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.jboss.eap.plugins</groupId>
                        <artifactId>eap-maven-plugin</artifactId>
                        <configuration>
                            ...
                            <feature-packs>
                                <feature-pack>
                                    <location>org.jboss.eap:wildfly-ee-galleon-pack</location>
                                </feature-pack>
                                <feature-pack>
                                    <location>org.jboss.eap.cloud:eap-cloud-galleon-pack</location>
                                </feature-pack>
                            </feature-packs>
                            <layers>...</layers>
                            <name>ROOT.war</name>
                        </configuration>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>package</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                    ...
                </plugins>
            </build>
        </profile>
----
endif::[]

ifndef::ProductRelease,EAPXPRelease[]
You may note that unlike the `provisioned-server` profile it uses the cloud feature pack which enables a configuration tuned for OpenShift environment.
endif::[]
ifdef::ProductRelease,EAPXPRelease[]
You may note that it uses the cloud feature pack which enables a configuration tuned for OpenShift environment.
endif::[]

:leveloffset: 1
// Getting Started with Helm
:leveloffset: +1

[[getting_started_with_helm]]
= Getting Started with {xpaasproduct-shortname} and Helm Charts

This section contains the basic instructions to build and deploy this quickstart to {xpaasproduct-shortname} or {xpaasproductOpenShiftOnline-shortname} using Helm Charts.

[[prerequisites_helm_openshift]]
== Prerequisites

* You must be logged in OpenShift and have an `oc` client to connect to OpenShift
* https://helm.sh[Helm] must be installed to deploy the backend on OpenShift.

Once you have installed Helm, you need to add the repository that provides Helm Charts for {productName}.

ifndef::ProductRelease,EAPXPRelease[]
[source,options="nowrap"]
----
$ helm repo add wildfly https://docs.wildfly.org/wildfly-charts/
"wildfly" has been added to your repositories
$ helm search repo wildfly
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
wildfly/wildfly         ...             ...            Build and Deploy WildFly applications on OpenShift
wildfly/wildfly-common  ...             ...            A library chart for WildFly-based applications
----
endif::[]
ifdef::ProductRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP {productVersion} applications
----
endif::[]
ifdef::EAPXPRelease[]
[source,options="nowrap",subs="+attributes"]
----
$ helm repo add jboss-eap https://jbossas.github.io/eap-charts/
"jboss-eap" has been added to your repositories
$ helm search repo jboss-eap
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
{helmChartName}         ...             ...             A Helm chart to build and deploy EAP XP {productVersion} applications
----
endif::[]

:leveloffset: 1

ifdef::helm-install-prerequisites[]
// Additional steps needed before deploying in Helm
[[deploy_helm_prerequisites]]
include::{helm-install-prerequisites}[leveloffset=+1]
endif::helm-install-prerequisites[]

//Prepare Helm for Quickstart Deployment
:leveloffset: +1


ifeval::[{useHelmChartDir} == true]
:helm_chart_values: charts
endif::[]
ifndef::useHelmChartDir[]
:helm_chart_values: -f charts/helm.yaml {helmChartName}
endif::[]
[[deploy_helm]]
== Deploy the {ProductShortName} Source-to-Image (S2I) Quickstart to OpenShift with Helm Charts

Log in to your OpenShift instance using the `oc login` command.
The backend will be built and deployed on OpenShift with a Helm Chart for {productName}.

Navigate to the root directory of this quickstart and run the following command:
[source,options="nowrap",subs="+attributes"]
----
$ helm install {helm-app-name} {helm_chart_values} --wait --timeout=10m0s
NAME: {helm-app-name}
...
STATUS: deployed
REVISION: 1
----

This command will return once the application has successfully deployed. In case of a timeout, you can check the status of the application with the following command in another terminal:

[source,options="nowrap",subs="+attributes"]
----
oc get deployment {helm-app-name}
----

The Helm Chart for this quickstart contains all the information to build an image from the source code using S2I on Java 17:


ifndef::requires-http-route[]
ifdef::useHelmChartDir[]
[source,yaml]
----
include::{docdir}/charts/Chart.yaml[]
----
endif::useHelmChartDir[]
ifndef::useHelmChartDir[]
[source,yaml]
----
build:
  uri: https://github.com/wildfly/quickstart.git
  ref: main
  contextDir: microprofile-config
deploy:
  replicas: 1
----
endif::useHelmChartDir[]
endif::requires-http-route[]

ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
build:
  uri: {githubRepoCodeUrl}
  ref: {WildFlyQuickStartRepoTag}
  contextDir: {artifactId}
deploy:
  replicas: 1
  route:
    tls:
      enabled: false
----
endif::requires-http-route[]

This will create a new deployment on OpenShift and deploy the application.

If you want to see all the configuration elements to customize your deployment you can use the following command:
[source,options="nowrap",subs="+attributes"]
----
$ helm show readme {helmChartName}
----


Get the URL of the route to the deployment.

[source,options="nowrap",subs="+attributes"]
----
$ oc get route {helm-app-name} -o jsonpath="{.spec.host}"
----
Access the application in your web browser using the displayed URL.

[NOTE]
====
The Maven profile named `openshift` is used by the Helm chart to provision the server with the quickstart deployed on the root web context, and thus the application should be accessed with the URL without the `/{artifactId}` path segment after `HOST:PORT`.
====

ifdef::post-helm-install-actions[]
include::{post-helm-install-actions}[leveloffset=+1]
endif::post-helm-install-actions[]


[[undeploy_helm]]
== Undeploy the {ProductShortName} Source-to-Image (S2I) Quickstart from OpenShift with Helm Charts


[source,options="nowrap",subs="+attributes"]
----
$ helm uninstall {helm-app-name}
----

:leveloffset: 1

// Testing on Openshift
:leveloffset: +1

[[run_the_integration_tests_with_openshift]]
= Run the Integration Tests with OpenShift
The integration tests included with this quickstart, which verify that the quickstart runs correctly, may also be run with the quickstart running on OpenShift.
[NOTE]
====
The integration tests expect a deployed application, so make sure you have deployed the quickstart on OpenShift before you begin.
====

ifdef::extra-openshift-testing-actions[]
include::{extra-openshift-testing-actions}[leveloffset=+1]
endif::extra-openshift-testing-actions[]

ifndef::extra-openshift-test-arguments[:extra-openshift-test-arguments:]

Run the integration tests using the following command to run the `verify` goal with the `integration-testing` profile activated and the proper URL:
ifndef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=https://$(oc get route {helm-app-name} --template='{{ .spec.host }}') {extra-openshift-test-arguments}
----
endif::requires-http-route[]
ifdef::requires-http-route[]
[source,options="nowrap",subs="+attributes"]
----
$ mvn verify -Pintegration-testing -Dserver.host=http://$(oc get route {helm-app-name} --template='{{ .spec.host }}') {extra-openshift-test-arguments}
----
endif::requires-http-route[]

[NOTE]
====
The tests are using SSL to connect to the quickstart running on OpenShift. So you need the certificates to be trusted by the machine the tests are run from.
====

:leveloffset: 1

:leveloffset!:

== Conclusion

MicroProfile Config provides a way for your application to separate the configuration
from your application code which is a requirement for modern applications targeting
containers and cloud deployments. It allows you to adjust every aspect of the
configuration according to the application needs. The more information can be found
in the https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/microprofile-config-spec.asciidoc[MicroProfile config specification].
